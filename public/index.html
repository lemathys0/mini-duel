<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Duel de Cartes</title>
    <style>
        /* Base Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #4a6a8c);
            color: #ecf0f1;
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px; /* Adjusted padding for smaller screens */
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align at the top for better scrolling on mobile */
            overflow-y: auto;
        }

        .container {
            background: rgba(0, 0, 0, 0.7);
            padding: 25px 15px; /* Adjusted padding */
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 100%; /* Full width on smaller screens */
            max-width: 600px;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 1;
            margin: 0 auto 30px auto; /* More margin at the bottom */
        }

        h1 {
            color: #e74c3c;
            margin-bottom: 20px;
            font-size: 2.2em; /* Slightly smaller for mobile */
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
        }

        h2 {
            color: #f1c40f;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.6em; /* Slightly smaller for mobile */
        }

        input[type="text"],
        input[type="password"] {
            width: calc(100% - 20px); /* Account for padding */
            padding: 10px; /* Smaller padding */
            margin-bottom: 12px; /* Smaller margin */
            border: 1px solid #34495e;
            border-radius: 8px;
            background-color: #1a252f;
            color: #ecf0f1;
            font-size: 0.95em;
            box-sizing: border-box;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px; /* Adjusted padding */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em; /* Adjusted font size */
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin: 4px; /* Smaller margin */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            flex-grow: 1; /* Allow buttons to grow in action group */
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: #5d6d7e;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .message {
            margin-top: 10px; /* Adjusted margin */
            font-weight: bold;
            min-height: 20px;
            color: #ff4d6d;
            font-size: 0.95em; /* Adjusted font size */
        }
        .message[style*="00ff88"] {
            color: #00ff88;
        }

        #auth, #match, #game {
            display: none;
        }

        #game {
            text-align: left;
        }

        .player-info {
            display: flex;
            flex-direction: column; /* Stack on mobile */
            align-items: flex-start; /* Align text left */
            margin-bottom: 15px; /* Adjusted margin */
            background: rgba(44, 62, 80, 0.6);
            padding: 12px; /* Adjusted padding */
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-info.you {
            background: rgba(39, 174, 96, 0.3);
        }

        .player-info.opponent {
            background: rgba(231, 76, 60, 0.3);
        }

        .player-name {
            font-size: 1.3em; /* Adjusted font size */
            font-weight: bold;
            color: #ecf0f1;
            margin-bottom: 5px; /* Space between name and health */
        }

        .health-bar-container {
            width: 100%; /* Full width */
            height: 18px; /* Slightly smaller height */
            background-color: #34495e;
            border-radius: 9px; /* Adjusted border radius */
            overflow: hidden;
            position: relative;
            margin-left: 0; /* No margin-left on mobile */
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .health-bar {
            height: 100%;
            width: 100%;
            background-color: #2ecc71; /* Default green */
            transition: width 0.5s ease-out, background-color 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em; /* Adjusted font size */
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Specific colors for health bars based on state/player */
        .health-bar.opponent-bar {
            background-color: #e74c3c; /* Red for opponent */
        }

        .health-bar.low {
            background-color: #e67e22; /* Orange for low health */
        }

        .health-bar.critical {
            background-color: #c0392b; /* Dark red for critical health */
        }

        .pv-display {
            margin-left: 0; /* No margin-left on mobile */
            margin-top: 5px; /* Space between health bar and PV */
            font-weight: bold;
            color: #ecf0f1;
            font-size: 1em; /* Adjusted font size */
            text-align: right;
            width: 100%; /* Full width for text alignment */
        }

        #opponent-action-status {
            margin-top: 8px; /* Space below opponent health */
            font-size: 0.8em;
            color: #bbb;
            text-align: center;
            width: 100%;
        }

        .game-controls {
            margin-top: 15px; /* Adjusted margin */
            padding: 12px; /* Adjusted padding */
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; /* Flexbox for buttons */
            flex-wrap: wrap; /* Wrap buttons on small screens */
            justify-content: center; /* Center buttons */
        }

        .game-controls p {
            font-size: 1.1em; /* Adjusted font size */
            margin-bottom: 12px;
            color: #ecf0f1;
            min-height: 20px;
            width: 100%; /* Full width for messages */
        }

        .timer-container {
            display: flex;
            flex-direction: column; /* Stack timer elements */
            align-items: center;
            margin-top: 12px; /* Adjusted margin */
            margin-bottom: 15px;
            background-color: #1a252f;
            border-radius: 8px;
            padding: 10px;
        }

        .timer-label {
            font-weight: bold;
            margin-right: 0; /* No margin-right on mobile */
            margin-bottom: 5px; /* Space below label */
            color: #f39c12;
            font-size: 0.95em;
        }

        .timer-bar-wrapper {
            width: 100%; /* Full width */
            height: 12px; /* Smaller height */
            background-color: #5d6d7e;
            border-radius: 6px; /* Adjusted border radius */
            overflow: hidden;
            position: relative;
        }

        .timer-progress-bar {
            height: 100%;
            width: 100%;
            background-color: #2ecc71; /* Default green, will change with JS */
            transition: width 0.5s ease-out, background-color 0.5s ease-out;
        }

        .timer-value {
            margin-left: 0; /* No margin-left on mobile */
            margin-top: 5px; /* Space above value */
            font-weight: bold;
            color: #ecf0f1;
            font-size: 0.9em;
        }

        .history-section {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px; /* Adjusted padding */
            border-radius: 10px;
            max-height: 120px; /* Smaller height */
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-section h3 {
            font-size: 1.1em; /* Adjusted font size */
            margin-bottom: 8px;
        }

        .history-section p {
            margin: 4px 0; /* Adjusted margin */
            font-size: 0.85em; /* Adjusted font size */
            color: #bdc3c7;
        }

        .history-section p:last-child {
            font-weight: bold;
            color: #ecf0f1;
        }

        /* Background animation (optional) */
        .bg-shapes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            pointer-events: none;
        }

        .bg-shapes div {
            position: absolute;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            animation: moveShape 10s infinite alternate;
        }

        .bg-shapes div:nth-child(1) { width: 60px; height: 60px; top: 10%; left: 20%; animation-duration: 12s; }
        .bg-shapes div:nth-child(2) { width: 100px; height: 100px; top: 50%; left: 80%; animation-duration: 15s; }
        .bg-shapes div:nth-child(3) { width: 40px; height: 40px; top: 80%; left: 40%; animation-duration: 10s; }
        .bg-shapes div:nth-child(4) { width: 80px; height: 80px; top: 30%; left: 10%; animation-duration: 13s; }
        .bg-shapes div:nth-child(5) { width: 70px; height: 70px; top: 60%; left: 60%; animation-duration: 11s; }

        @keyframes moveShape {
            0% { transform: translate(0, 0) scale(1); opacity: 0.05; }
            100% { transform: translate(20px, 30px) scale(1.1); opacity: 0.08; }
        }

        /* Health bar animation effects */
        .health-bar.damage-effect {
            animation: flashRed 0.5s ease-out;
        }
        .health-bar.heal-effect {
            animation: flashGreen 1s ease-out;
        }
        @keyframes flashRed {
            0% { background-color: #e74c3c; } /* Current danger red */
            50% { background-color: #f06292; } /* Brighter red */
            100% { background-color: #e74c3c; } /* Back to danger red */
        }

        @keyframes flashGreen {
            0% { background-color: #2ecc71; } /* Current heal green */
            50% { background-color: #a7f7b7; } /* Lighter green */
            100% { background-color: #2ecc71; } /* Back to heal green */
        }


        /* Desktop/Tablet Styles (min-width 768px) */
        @media (min-width: 768px) {
            body {
                padding: 20px;
                align-items: center; /* Center vertically on larger screens */
            }

            .container {
                padding: 30px;
                max-width: 600px;
                margin: 0 auto;
            }

            h1 {
                font-size: 2.5em;
            }

            h2 {
                font-size: 1.8em;
            }

            input[type="text"],
            input[type="password"] {
                padding: 12px;
                margin-bottom: 15px;
                font-size: 1em;
            }

            button {
                padding: 12px 25px;
                font-size: 1.1em;
                margin: 5px;
            }

            .message {
                margin-top: 15px;
                font-size: 1em;
            }

            .player-info {
                flex-direction: row; /* Row on larger screens */
                align-items: center;
                margin-bottom: 20px;
                padding: 15px;
            }

            .player-name {
                font-size: 1.5em;
                margin-bottom: 0;
                flex-grow: 1; /* Takes remaining space */
            }

            .health-bar-container {
                width: 150px; /* Fixed width */
                height: 20px;
                margin-left: 20px; /* Restore margin */
            }

            .health-bar {
                font-size: 0.8em;
            }

            .pv-display {
                margin-left: 10px; /* Restore margin */
                margin-top: 0;
                width: auto;
            }

            #opponent-action-status {
                margin-top: 0;
                margin-left: 20px;
                font-size: 0.9em;
                text-align: left;
                width: auto;
            }

            .game-controls {
                margin-top: 20px;
                padding: 15px;
                flex-wrap: nowrap; /* No wrap on larger screens */
            }

            .game-controls p {
                font-size: 1.2em;
                margin-bottom: 15px;
            }

            .timer-container {
                flex-direction: row; /* Row on larger screens */
                margin-top: 15px;
                margin-bottom: 20px;
            }

            .timer-label {
                margin-right: 10px;
                margin-bottom: 0;
                font-size: 1em;
            }

            .timer-bar-wrapper {
                flex-grow: 1; /* Takes remaining space */
                height: 15px;
            }

            .timer-value {
                margin-left: 10px;
                margin-top: 0;
                font-size: 1em;
            }

            .history-section {
                padding: 15px;
                max-height: 150px;
                margin-top: 20px;
            }

            .history-section h3 {
                font-size: 1.2em;
            }

            .history-section p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="bg-shapes">
        <div></div><div></div><div></div><div></div><div></div>
    </div>

    <div class="container">
        <h1>Mini Duel de Cartes</h1>

        <div id="auth">
            <h2>Authentification</h2>
            <input type="text" id="pseudo" placeholder="Votre Pseudo">
            <input type="password" id="code" placeholder="Votre Code (4 chiffres)">
            <button id="login-btn">Se Connecter</button>
            <button id="signup-btn">S'inscrire</button>
            <p id="auth-msg" class="message"></p>
        </div>

        <div id="match">
            <h2>Bienvenue <span id="player-name" style="color:#f1c40f;"></span> !</h2>
            <h3>Rejoindre ou Créer un Match</h3>
            <input type="text" id="match-id" placeholder="Code du Match (ex: ABC123)">
            <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-top: 10px;">
                <button id="join-match-btn" style="flex: 1 1 auto; margin: 5px;">Rejoindre Match</button>
                <button id="create-match-btn" style="flex: 1 1 auto; margin: 5px;">Créer Match</button>
                <button id="play-ai-btn" style="flex: 1 1 auto; margin: 5px; background-color: #27ae60;">Jouer contre l'IA</button>
            </div>
            <p id="match-msg" class="message"></p>
        </div>

        <div id="game">
            <h2>Match: <span id="current-match" style="color:#f1c40f;"></span></h2>

            <div class="player-info you">
                <span id="you-name" class="player-name">Vous</span>
                <div class="health-bar-container">
                    <div class="health-bar" id="you-health-bar"></div>
                </div>
                <span class="pv-display" id="you-pv-display">100 PV</span>
            </div>

            <div class="player-info opponent">
                <span id="opponent-name" class="player-name">Adversaire</span>
                <div class="health-bar-container">
                    <div class="health-bar opponent-bar" id="opponent-health-bar"></div>
                </div>
                <span class="pv-display" id="opponent-pv-display">100 PV</span>
                <span id="opponent-action-status"></span>
            </div>

            <div class="timer-container">
                <span class="timer-label">Temps restant:</span>
                <div class="timer-bar-wrapper">
                    <div class="timer-progress-bar" id="timer-progress-bar"></div>
                </div>
                <span class="timer-value" id="timer-value">20</span>
            </div>

            <div class="game-controls">
                <p id="action-msg" class="message"></p>
                <button id="attack-btn">Attaquer (10 dégâts)</button>
                <button id="defend-btn">Défendre (-5 dégâts reçus)</button>
                <button id="heal-btn">Soigner (+15 PV)</button>
            </div>

            <div class="history-section">
                <h3>Historique du match</h3>
                <div id="history">
                    </div>
            </div>
            <button id="back-to-menu-btn" style="margin-top: 20px; background-color: #9b59b6;">Retour au Menu</button>
        </div>
    </div>

    <script type="module">
        // Import Firebase (corrected paths)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, update, push, child, remove, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

        // --- CONFIGURATION FIREBASE ---
        const firebaseConfig = {
            apiKey: "YOUR_FIREBASE_API_KEY", // REMPLACEZ PAR VOTRE VRAIE CLÉ API
            authDomain: "mini-duel-de-cartes.firebaseapp.com",
            databaseURL: "https://mini-duel-de-cartes-default-rtdb.firebaseio.com",
            projectId: "mini-duel-de-cartes",
            storageBucket: "mini-duel-de-cartes.appspot.com",
            messagingSenderId: "1084207708579",
            appId: "1:1084207708579:web:f1312b68b7eb08f9d44216",
            measurementId: "G-7YW3J41XZF"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- VARIABLES GLOBALES ---
        let currentUser = null; // { pseudo, code }
        let currentMatchId = null;
        // hasPlayedThisTurn : Vrai si le joueur a soumis son action pour le tour ACTUEL.
        // Cette variable est essentielle pour éviter de soumettre plusieurs actions par tour.
        // Elle sera réinitialisée uniquement lorsque le tour est processé par le P1.
        let hasPlayedThisTurn = false;
        let timerInterval = null;
        const timerMax = 20; // secondes (réduit le temps pour un jeu plus rapide)
        // timerCount n'est plus géré directement par le script, mais par le calcul basé sur lastTurnProcessedAt
        let youKey = null; // 'p1' or 'p2' for the current user in the match
        let opponentKey = null; // 'p1' or 'p2' for the opponent
        let gameMode = 'PvP'; // 'PvP' (Player vs Player) ou 'PvAI' (Player vs AI)

        let unsubscribeMatchCreationListener = null;
        let matchDeletionTimeout = null;
        let currentMatchUnsubscribe = null;
        let onDisconnectRef = null; // To store the onDisconnect reference for proper cancellation

        // --- DOM Elements Cache ---
        const pseudoInput = document.getElementById("pseudo");
        const codeInput = document.getElementById("code");
        const authMsgEl = document.getElementById("auth-msg");
        const matchIdInput = document.getElementById("match-id");
        const matchMsgEl = document.getElementById("match-msg");
        const actionMsgEl = document.getElementById("action-msg");
        const youPvDisplayEl = document.getElementById("you-pv-display");
        const opponentPvDisplayEl = document.getElementById("opponent-pv-display");
        const youHealthBarEl = document.getElementById("you-health-bar");
        const opponentHealthBarEl = document.getElementById("opponent-health-bar");
        const timerValueEl = document.getElementById("timer-value");
        const timerProgressBarEl = document.getElementById("timer-progress-bar");
        const attackBtn = document.getElementById("attack-btn");
        const defendBtn = document.getElementById("defend-btn");
        const healBtn = document.getElementById("heal-btn");
        const backToMenuBtn = document.getElementById("back-to-menu-btn");
        const opponentActionStatusEl = document.getElementById("opponent-action-status"); // Nouvel élément
        const playAiBtn = document.getElementById("play-ai-btn"); // Nouveau bouton


        // --- FONCTIONS UTILITAIRES ---

        function showMessage(elementId, message, isSuccess = false) {
            const el = document.getElementById(elementId);
            if (el) {
                el.style.color = isSuccess ? "#00ff88" : "#ff4d6d";
                el.textContent = message;
                // Efface le message après un court délai s'il s'agit d'un message temporaire
                if (!isSuccess) {
                    setTimeout(() => {
                        if (el.textContent === message) el.textContent = "";
                    }, 5000);
                }
            }
        }

        function disableActionButtons(disabled) {
            attackBtn.disabled = disabled;
            defendBtn.disabled = disabled;
            healBtn.disabled = disabled;
        }

        function updateHealthBar(healthBarElement, pvDisplayElement, currentPV, isOpponent = false) {
            const percentage = Math.max(0, Math.min(100, currentPV));
            healthBarElement.style.width = `${percentage}%`;
            healthBarElement.textContent = `${Math.round(percentage)}%`; // Arrondi le pourcentage

            // Ajout d'une animation si les PV ont changé (visuel)
            const oldPVText = pvDisplayElement.textContent;
            const oldPV = parseInt(oldPVText.replace(' PV', '')); // Convert "100 PV" to 100
            if (!isNaN(oldPV)) {
                if (currentPV < oldPV) { // Dégâts
                    healthBarElement.classList.add('damage-effect');
                    setTimeout(() => healthBarElement.classList.remove('damage-effect'), 500);
                } else if (currentPV > oldPV) { // Soin
                    healthBarElement.classList.add('heal-effect');
                    setTimeout(() => healthBarElement.classList.remove('heal-effect'), 1000);
                }
            }

            pvDisplayElement.textContent = `${currentPV} PV`; // Display PV with "PV" suffix

            healthBarElement.classList.remove('low', 'critical');
            if (isOpponent) {
                healthBarElement.classList.add('opponent-bar'); // Always apply opponent specific styling
            } else {
                healthBarElement.classList.remove('opponent-bar'); // Remove if not opponent
            }

            if (currentPV < 10) {
                healthBarElement.classList.add('critical');
            } else if (currentPV < 30) {
                healthBarElement.classList.add('low');
            } else {
                // Reset to default green if not low/critical/opponent
                if (!isOpponent) {
                    healthBarElement.style.backgroundColor = ''; // Remove inline style to use CSS default
                }
            }
        }

        function updateTimerUI(value) {
            timerValueEl.textContent = value;
            const progress = (value / timerMax) * 100;
            timerProgressBarEl.style.width = `${progress}%`;
            // Interpolation de couleur du vert au rouge
            const r = Math.min(255, Math.floor((100 - progress) * 2.55 * 2));
            const g = Math.min(255, Math.floor(progress * 2.55 * 2));
            timerProgressBarEl.style.backgroundColor = `rgb(${r}, ${g}, 0)`;
        }


        // --- AUTHENTIFICATION ---

        document.getElementById("signup-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (pseudo.length < 2) {
                showMessage("auth-msg", "Pseudo trop court (min 2 caractères).");
                return;
            }
            if (!/^\d{4}$/.test(code)) {
                showMessage("auth-msg", "Code doit être composé de 4 chiffres.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("auth-msg", "Ce pseudo est déjà pris.");
                } else {
                    set(userRef, { code, wins: 0, losses: 0, createdAt: serverTimestamp() })
                        .then(() => {
                            showMessage("auth-msg", "Inscription réussie !", true);
                            currentUser = { pseudo, code };
                            afterLogin();
                        })
                        .catch(error => {
                            console.error("Signup error:", error);
                            showMessage("auth-msg", "Erreur lors de l'inscription.");
                        });
                }
            }).catch(error => {
                console.error("Checking user for signup error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("login-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (!pseudo || !code) {
                showMessage("auth-msg", "Pseudo et code requis.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("auth-msg", "Pseudo inconnu.");
                } else {
                    const data = snapshot.val();
                    if (data.code === code) {
                        showMessage("auth-msg", "Connexion réussie !", true);
                        currentUser = { pseudo, code };
                        afterLogin();
                    }
                    else {
                        showMessage("auth-msg", "Code incorrect.");
                    }
                }
            }).catch(error => {
                console.error("Login error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        function afterLogin() {
            document.getElementById("auth").style.display = "none";
            document.getElementById("match").style.display = "block";
            document.getElementById("player-name").textContent = currentUser.pseudo;
            showMessage("auth-msg", ""); // Clear auth message
            pseudoInput.value = ""; // Clear inputs
            codeInput.value = "";
        }

        // --- MATCH ---

        document.getElementById("create-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code pour le match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("match-msg", "Ce code de match est déjà utilisé.");
                } else {
                    gameMode = 'PvP'; // Set game mode to PvP
                    const initialMatchData = {
                        players: {
                            p1: { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null },
                            p2: null
                        },
                        turn: "p1", // Initial turn
                        history: [`Match ${matchId} créé par ${currentUser.pseudo}. En attente d'un adversaire...`],
                        status: "waiting", // waiting, playing, finished, forfeited
                        createdAt: serverTimestamp(),
                        lastTurnProcessedAt: serverTimestamp() // Timestamp to help sync timer across clients
                    };
                    set(matchRef, initialMatchData).then(() => {
                        showMessage("match-msg", "Match créé. En attente de l'adversaire...", true);
                        startMatchMonitoring(matchId);

                        // Cleanup listener for unjoined match - improved
                        if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); // Clear previous
                        unsubscribeMatchCreationListener = onValue(matchRef, (matchSnapshot) => {
                            const matchData = matchSnapshot.val();
                            if (!matchData) { // Match was deleted
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                                return;
                            }
                            if (matchData.status === 'waiting' && !matchData.players.p2 && matchData.createdAt) {
                                const timeElapsed = Date.now() - matchData.createdAt;
                                if (timeElapsed > 60000) { // 1 minute timeout for waiting match
                                    console.log(`Match ${matchId} non rejoint après 1 minute, suppression.`);
                                    remove(matchRef)
                                        .then(() => {
                                            showMessage("match-msg", "Match expiré et supprimé (aucun adversaire).");
                                            if (currentMatchId === matchId) {
                                                backToMenu(true);
                                            }
                                        })
                                        .catch(err => console.error("Error removing expired match:", err));
                                    if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                    unsubscribeMatchCreationListener = null;
                                }
                            } else if (matchData.players.p2 && matchData.status === 'playing') { // Opponent joined
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                            }
                        });

                    }).catch(error => {
                        console.error("Error creating match:", error);
                        showMessage("match-msg", "Erreur lors de la création du match.");
                    });
                }
            }).catch(error => {
                console.error("Error checking match existence:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("join-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code de match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("match-msg", "Ce match n'existe pas.");
                    return;
                }

                const matchData = snapshot.val();
                if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                    showMessage("match-msg", "Vous êtes déjà le créateur de ce match. Attendez un joueur.");
                    startMatchMonitoring(matchId);
                    return;
                }
                if (matchData.players.p2) {
                    showMessage("match-msg", "Ce match est déjà complet.");
                    return;
                }
                if (matchData.status !== 'waiting') {
                    showMessage("match-msg", "Ce match n'est plus en attente de joueurs.");
                    return;
                }

                gameMode = 'PvP'; // Set game mode to PvP
                const updates = {};
                updates[`players/p2`] = { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null };
                updates[`status`] = 'playing';
                updates[`history`] = [...(matchData.history || []), `${currentUser.pseudo} a rejoint le match ! Le duel commence.`];
                updates[`lastTurnProcessedAt`] = serverTimestamp(); // Sync timer on join

                update(matchRef, updates).then(() => {
                    showMessage("match-msg", "Vous avez rejoint le match !", true);
                    startMatchMonitoring(matchId);
                }).catch(error => {
                    console.error("Error joining match:", error);
                    showMessage("match-msg", "Erreur pour rejoindre le match.");
                });
            }).catch(error => {
                console.error("Error getting match to join:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };

        // --- NOUVEAU : Jouer contre l'IA ---
        playAiBtn.onclick = async () => {
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            gameMode = 'PvAI'; // Set game mode to PvAI
            console.log(`[AI Mode] Starting AI match. gameMode set to: ${gameMode}`); // Log added
            const aiMatchId = "AI_" + currentUser.pseudo + "_" + Date.now().toString().slice(-6); // Unique ID for AI match

            const matchRef = ref(db, `matches/${aiMatchId}`);
            const initialMatchData = {
                players: {
                    p1: { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null },
                    p2: { pseudo: "IA", pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null } // IA est p2
                },
                turn: "p1", // Le joueur commence toujours
                history: [`Match IA ${aiMatchId} créé par ${currentUser.pseudo}. Le duel contre l'IA commence !`],
                status: "playing", // Le match commence immédiatement
                createdAt: serverTimestamp(),
                lastTurnProcessedAt: serverTimestamp()
            };

            try {
                await set(matchRef, initialMatchData);
                showMessage("match-msg", "Match contre l'IA créé. Bonne chance !", true);
                startMatchMonitoring(aiMatchId);
            } catch (error) {
                console.error("Error creating AI match:", error);
                showMessage("match-msg", "Erreur lors de la création du match IA.");
            }
        };


        // --- DÉBUT ET SUIVI DU MATCH ---
        function startMatchMonitoring(id) {
            // Nettoyage des listeners précédents
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                console.log("Timer interval cleared (startMatchMonitoring)."); // Log added
            }
            if (onDisconnectRef) {
                onDisconnectRef.cancel().catch(err => console.error("Error canceling old onDisconnect:", err));
                onDisconnectRef = null;
            }
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
            }
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
            }

            currentMatchId = id;
            const matchRef = ref(db, `matches/${id}`);

            document.getElementById("match").style.display = "none";
            document.getElementById("game").style.display = "block";
            document.getElementById("current-match").textContent = id;
            document.getElementById("you-name").textContent = currentUser.pseudo;
            document.getElementById("history").innerHTML = ""; // Clear history on new match start
            if (opponentActionStatusEl) opponentActionStatusEl.textContent = ""; // Clear opponent status

            // IMPORTANT : Réinitialiser hasPlayedThisTurn au début d'un nouveau match
            hasPlayedThisTurn = false;
            disableActionButtons(true); // Initialisation: boutons désactivés
            actionMsgEl.textContent = "Chargement du match...";

            currentMatchUnsubscribe = onValue(matchRef, async (snapshot) => {
                console.log("onValue triggered (full snapshot):", snapshot.val()); // Pour le débogage
                const data = snapshot.val();
                if (!data) {
                    // Match supprimé ou inexistant
                    if (currentMatchId === id) {
                        showMessage("action-msg", "Le match a été terminé ou supprimé.");
                        if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                        currentMatchUnsubscribe = null;
                        setTimeout(() => backToMenu(true), 3000);
                    }
                    return;
                }

                // Déterminer le rôle du joueur actuel (p1 ou p2)
                let you, opponent;
                if (data.players.p1 && data.players.p1.pseudo === currentUser.pseudo) {
                    you = data.players.p1; youKey = "p1";
                    opponent = data.players.p2; opponentKey = "p2";
                } else if (data.players.p2 && data.players.p2.pseudo === currentUser.pseudo) {
                    you = data.players.p2; youKey = "p2";
                    opponent = data.players.p1; opponentKey = "p1";
                } else {
                    // N'est pas un joueur dans ce match (ex: a été déconnecté/kické)
                    actionMsgEl.textContent = "Vous n'êtes pas un joueur dans ce match.";
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    console.log("Timer interval cleared (not player in match)."); // Log added
                    return;
                }

                // Mettre à jour lastSeen et définir onDisconnect (seulement pour PvP)
                if (gameMode === 'PvP') {
                    const yourPlayerRef = ref(db, `matches/${id}/players/${youKey}`);
                    if (!onDisconnectRef) { // Set onDisconnect only once per match
                        onDisconnectRef = onDisconnect(yourPlayerRef);
                        onDisconnectRef.update({
                            pv: 0, // Set PV to 0 on disconnect as a forfeit
                            status: 'forfeited', // Mark as forfeited
                            lastSeen: serverTimestamp()
                        }).catch(error => console.error("Error setting onDisconnect:", error));
                    }
                    // Mise à jour régulière de lastSeen pour signaler la présence
                    update(yourPlayerRef, { lastSeen: serverTimestamp(), status: 'connected' });
                }


                // Mettre à jour l'interface avec les données des joueurs
                updateHealthBar(youHealthBarEl, youPvDisplayEl, you.pv);
                document.getElementById("you-name").textContent = `${you.pseudo} (Vous)`;

                let opponentActionStatus = ""; // Initialisation vide
                if (opponent) {
                    updateHealthBar(opponentHealthBarEl, opponentPvDisplayEl, opponent.pv, true); // true pour l'adversaire
                    document.getElementById("opponent-name").textContent = opponent.pseudo;
                    // Afficher si l'adversaire a soumis son action
                    if (opponent.action) {
                        opponentActionStatus = "Action soumise !";
                    } else if (data.turn === opponentKey) { // C'est le tour de l'adversaire et il n'a pas encore joué
                        opponentActionStatus = "En attente d'action de l'adversaire...";
                    } else { // Si ce n'est pas son tour et il n'a pas d'action (normal)
                        opponentActionStatus = "";
                    }

                    // Détection de forfait de l'adversaire via status ou PV (seulement pour PvP)
                    if (gameMode === 'PvP' && (opponent.status === 'forfeited' || opponent.pv <= 0)) {
                        actionMsgEl.textContent = `L'adversaire (${opponent.pseudo}) a quitté le match ou est vaincu.`;
                        handleGameEnd(data, youKey, opponentKey, 'win'); // Vous gagnez par forfait ou KO
                    }
                } else {
                    opponentPvDisplayEl.textContent = "N/A";
                    opponentHealthBarEl.style.width = "0%";
                    opponentHealthBarEl.textContent = "0%";
                    document.getElementById("opponent-name").textContent = "En attente...";
                    opponentActionStatus = "En attente d'un adversaire...";
                }
                if (opponentActionStatusEl) opponentActionStatusEl.textContent = opponentActionStatus;

                // Conditions de fin de jeu (après avoir géré l'attente du P2)
                if (data.status === 'finished' || you.pv <= 0 || (opponent && opponent.pv <= 0)) {
                    // Unsubscribe onDisconnect as match is ending
                    if (onDisconnectRef) {
                        onDisconnectRef.cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                        onDisconnectRef = null;
                    }

                    let finalResult = "draw";
                    if (you.pv > 0 && (opponent && opponent.pv <= 0)) { // Vous avez plus de 0 PV et l'adversaire est à 0 ou moins
                        finalResult = "win";
                    } else if (you.pv <= 0 && (opponent && opponent.pv > 0)) { // Vous êtes à 0 PV ou moins et l'adversaire a encore des PV
                        finalResult = "loss";
                    }
                    handleGameEnd(data, youKey, opponentKey, finalResult);
                    return;
                }

                // Si le match est en attente du P2 (seulement pour PvP)
                if (gameMode === 'PvP' && (data.status === "waiting" || !opponent)) {
                    actionMsgEl.textContent = "En attente de l'adversaire...";
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    console.log("Timer interval cleared (waiting for opponent)."); // Log added
                    updateTimerUI(timerMax); // Reset timer display
                    return;
                }

                // Logs pour le débogage des actions
                console.log("P1 action (from data):", data.players.p1?.action, "P2 action (from data):", data.players.p2?.action);


                // --- LOGIQUE CLÉ POUR GÉRER LE TOUR ET LE TIMER ---
                const currentTime = Date.now();
                // Assurez-vous que lastTurnProcessedAt est un nombre avant de l'utiliser
                const lastTurnProcessedTime = data.lastTurnProcessedAt && typeof data.lastTurnProcessedAt.toMillis === 'function'
                    ? data.lastTurnProcessedAt.toMillis()
                    : currentTime; // Si non défini ou pas un ServerTimestamp, utilise le temps actuel
                const elapsedSinceLastTurn = Math.floor((currentTime - lastTurnProcessedTime) / 1000);

                let activePlayerKey = data.turn; // C'est le joueur dont c'est le tour selon la DB
                let activePlayer = data.players[activePlayerKey];

                console.log(`[Turn Logic] Current turn: ${data.turn}, Active Player Key: ${activePlayerKey}, Active Player Action: ${activePlayer?.action}`); // Log added
                console.log(`[Turn Logic] Elapsed since last turn processed: ${elapsedSinceLastTurn}s`); // Log added

                // Si le joueur actif n'a pas encore soumis son action
                if (!activePlayer.action) {
                    const timeRemaining = Math.max(0, timerMax - elapsedSinceLastTurn);
                    updateTimerUI(timeRemaining);

                    if (timerInterval) {
                        clearInterval(timerInterval); // Arrête tout timer précédent
                        timerInterval = null;
                        console.log("Timer interval cleared (new turn state detected / action pending)."); // Log added
                    }

                    if (youKey === activePlayerKey) {
                        // C'est mon tour, et je n'ai pas soumis d'action
                        if (!hasPlayedThisTurn) { // 'hasPlayedThisTurn' prévient le re-lancement du timer si l'action est déjà cliquée
                            disableActionButtons(false);
                            actionMsgEl.textContent = "C'est votre tour ! Choisissez une action.";
                            console.log(`Your turn (${youKey}), activating buttons and starting timer.`);
                            timerInterval = setInterval(() => {
                                const currentElapsed = Math.floor((Date.now() - lastTurnProcessedTime) / 1000);
                                const currentRemaining = Math.max(0, timerMax - currentElapsed);
                                updateTimerUI(currentRemaining);
                                console.log(`Timer tick for ${youKey}: ${currentRemaining}s remaining.`); // Log added
                                if (currentRemaining <= 0) {
                                    clearInterval(timerInterval);
                                    timerInterval = null;
                                    console.log("Timer interval cleared (timeout reached)."); // Log added
                                    console.log(`Timer for ${currentUser.pseudo} (${youKey}) expired. Submitting default action for YOU.`);
                                    submitDefaultAction(youKey, matchRef, data); // Soumet pour CE joueur
                                }
                            }, 1000);
                            console.log("Timer interval set for:", youKey); // Log added
                        } else {
                             // J'ai déjà joué mon action pour ce tour, j'attends l'adversaire
                             disableActionButtons(true);
                             actionMsgEl.textContent = "Action jouée. En attente de l'adversaire...";
                             console.log(`Your turn (${youKey}), action played. Waiting for opponent.`); // Log added
                        }
                    } else { // C'est le tour de l'adversaire (et il n'a pas soumis son action)
                        disableActionButtons(true);
                        actionMsgEl.textContent = `Tour de ${opponent ? opponent.pseudo : 'l\'adversaire'}. Veuillez patienter...`;
                        console.log(`Opponent's turn (${opponentKey}). Time remaining: ${timeRemaining}`);

                        // Si le temps de l'adversaire est écoulé, soumettre son action par défaut
                        // N'importe quel client peut soumettre l'action par défaut pour éviter le blocage.
                        if (timeRemaining <= 0) {
                            console.log(`Opponent (${activePlayerKey}) has timed out. Submitting default action for them.`);
                            submitDefaultAction(activePlayerKey, matchRef, data); // Soumet pour l'adversaire
                        }
                        // --- NOUVEAU : Logique de l'IA ---
                        if (gameMode === 'PvAI' && activePlayerKey === 'p2' && !activePlayer.action) {
                            // C'est le tour de l'IA et elle n'a pas encore joué
                            console.log("[AI Logic] It's AI's turn (p2) and AI has not played yet. Scheduling AI action.");
                            setTimeout(() => {
                                // Re-vérifier l'état du match avant que l'IA ne joue
                                get(matchRef).then(latestSnapshot => {
                                    const latestData = latestSnapshot.val();
                                    console.log("[AI Logic] Inside setTimeout. Latest data:", latestData); // Log added
                                    // S'assurer que le tour n'a pas changé et que l'IA n'a pas déjà d'action
                                    if (latestData && latestData.turn === 'p2' && !latestData.players.p2?.action) {
                                        console.log("[AI Logic] Conditions met to call aiTurn."); // Log added
                                        aiTurn(latestData.players.p1.pv, latestData.players.p2.pv, matchRef);
                                    } else {
                                        console.log("[AI Logic] AI's turn skipped in setTimeout: action already submitted or turn changed."); // Log added
                                    }
                                }).catch(err => console.error("[AI Logic] Error getting match data for AI turn:", err));
                            }, 1500); // Délai de 1.5 secondes pour simuler la "réflexion" de l'IA
                        }
                        // --- FIN NOUVEAU : Logique de l'IA ---
                    }
                } else { // L'action du joueur actif est déjà soumise
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                        console.log("Timer interval cleared (action submitted)."); // Log added
                    }
                    updateTimerUI(timerMax); // Reset timer UI to full if actions are present

                    // Si les deux actions (P1 et P2) sont présentes dans Firebase, et que ce client est P1,
                    // alors P1 est responsable du traitement du tour.
                    if (data.players.p1?.action && data.players.p2?.action) {
                         if (youKey === 'p1') {
                            console.log("P1 detected both actions, processing turn.");
                            // Pas de délai ici, on traite directement
                            processTurn(data, youKey, opponentKey, matchRef);
                        } else {
                            console.log("P2 detected both actions. Waiting for P1 to process.");
                            disableActionButtons(true); // Assurez-vous que les boutons sont désactivés
                            actionMsgEl.textContent = "Actions soumises. En attente du traitement du tour...";
                        }
                    } else {
                        // Une action est soumise, mais pas encore les deux (ex: mon action soumise, j'attends l'adversaire)
                        disableActionButtons(true);
                        actionMsgEl.textContent = "Action jouée. En attente de l'adversaire...";
                    }
                }
                // --- FIN LOGIQUE CLÉ ---


                // Mettre à jour l'historique
                const histEl = document.getElementById("history");
                histEl.innerHTML = "";
                (data.history || []).forEach(entry => {
                    const p = document.createElement("p");
                    p.textContent = entry;
                    histEl.appendChild(p);
                });
                histEl.scrollTop = histEl.scrollHeight;

            }, (error) => {
                console.error("Error listening to match data:", error);
                showMessage("action-msg", "Erreur de connexion au match. Retour au menu.");
                if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
                setTimeout(() => backToMenu(true), 3000);
            });
        }

        // --- RESOLUTION DU TOUR ---
        async function processTurn(data, youKeyCurrentListener, opponentKeyCurrentListener, matchRef) {
            console.log("processTurn started (by P1 if logic is followed) with data:", JSON.stringify(data));
            console.log("data.turn at start of processTurn (current turn):", data.turn); // AJOUTÉ POUR DÉBOGAGE

            // Vérifiez encore une fois que les actions sont non-nulles pour éviter le double traitement
            if (!data.players.p1?.action || !data.players.p2?.action) { // Utilisation de ?. pour la sûreté
                console.warn("processTurn called but one or both actions are null (or missing). Exiting (already processed or not ready).");
                return; // Ne rien faire si les actions sont déjà effacées
            }

            if (timerInterval) {
                clearInterval(timerInterval); // Stop timer immediately when processing
                timerInterval = null;
                console.log("Timer interval cleared (processTurn)."); // Log added
            }
            disableActionButtons(true); // Disable buttons during processing

            // IMPORTANT : Réinitialiser hasPlayedThisTurn ici car le tour est sur le point d'être traité
            // Cela garantit que lorsque le nouveau tour commencera, le joueur pourra de nouveau jouer.
            hasPlayedThisTurn = false;

            const p1Action = data.players.p1.action;
            const p2Action = data.players.p2.action;

            let p1PV = data.players.p1.pv;
            let p2PV = data.players.p2.pv;
            let historyUpdates = [...(data.history || [])];

            historyUpdates.push(`--- Début du tour ---`);

            // Logique d'application des actions
            // Attaque
            if (p1Action === 'attack') {
                historyUpdates.push(`${data.players.p1.pseudo} attaque !`);
                if (p2Action === 'defend') {
                    p2PV -= 5;
                    historyUpdates.push(`${data.players.p2.pseudo} se défend, subit 5 PV de dégâts.`);
                } else {
                    p2PV -= 10;
                    historyUpdates.push(`${data.players.p2.pseudo} subit 10 PV de dégâts.`);
                }
            }
            if (p2Action === 'attack') {
                historyUpdates.push(`${data.players.p2.pseudo} attaque !`);
                if (p1Action === 'defend') {
                    p1PV -= 5;
                    historyUpdates.push(`${data.players.p1.pseudo} se défend, subit 5 PV de dégâts.`);
                } else {
                    p1PV -= 10;
                    historyUpdates.push(`${data.players.p1.pseudo} subit 10 PV de dégâts.`);
                }
            }

            // Soin
            if (p1Action === 'heal') {
                p1PV = Math.min(100, p1PV + 15);
                historyUpdates.push(`${data.players.p1.pseudo} se soigne et récupère 15 PV.`);
            }
            if (p2Action === 'heal') {
                p2PV = Math.min(100, p2PV + 15);
                historyUpdates.push(`${data.players.p2.pseudo} se soigne et récupère 15 PV.`);
            }

            // Défense (déjà géré dans l'attaque, mais on peut loguer pour la clarté)
            if (p1Action === 'defend' && p2Action !== 'attack') {
                historyUpdates.push(`${data.players.p1.pseudo} se met en position défensive.`);
            }
            if (p2Action === 'defend' && p1Action !== 'attack') {
                historyUpdates.push(`${data.players.p2.pseudo} se met en position défensive.`);
            }

            historyUpdates.push(`--- Fin du tour ---`);

            // S'assurer que les PV ne sont pas négatifs
            p1PV = Math.max(0, p1PV);
            p2PV = Math.max(0, p2PV);

            // Déterminer le prochain tour ou la fin du match
            let nextTurn = (data.turn === 'p1') ? 'p2' : 'p1';
            console.log(`Current turn was: ${data.turn}, Calculated next turn: ${nextTurn}`); // AJOUTÉ POUR DÉBOGAGE

            let gameStatus = 'playing';
            let winner = null;
            let loser = null;

            if (p1PV <= 0 && p2PV <= 0) {
                gameStatus = "finished";
                winner = "draw";
                historyUpdates.push("Les deux joueurs sont à terre. C'est un match nul !");
            } else if (p1PV <= 0) {
                gameStatus = "finished";
                winner = "p2";
                loser = "p1";
                historyUpdates.push(`${data.players.p1.pseudo} est vaincu ! ${data.players.p2.pseudo} gagne le match.`);
            } else if (p2PV <= 0) {
                gameStatus = "finished";
                winner = "p1";
                loser = "p2";
                historyUpdates.push(`${data.players.p2.pseudo} est vaincu ! ${data.players.p1.pseudo} gagne le match.`);
            }

            const updates = {
                [`players/p1/pv`]: p1PV,
                [`players/p2/pv`]: p2PV,
                [`players/p1/action`]: null, // Réinitialise l'action du joueur 1 pour le prochain tour
                [`players/p2/action`]: null, // Réinitialise l'action du joueur 2 pour le prochain tour
                history: historyUpdates,
                turn: nextTurn, // C'est cette valeur qui doit être mise à jour dans Firebase
                status: gameStatus,
                lastTurnProcessedAt: serverTimestamp() // Mettre à jour le timestamp pour le timer
            };

            if (winner) {
                updates.winner = winner;
                if (loser) updates.loser = loser;
            }

            console.log("DEBUG: Final updates payload sent to Firebase (processTurn):", JSON.stringify(updates, null, 2)); // AJOUTÉ POUR DÉBOGAGE
            try {
                // Utiliser une mise à jour atomique pour garantir la cohérence
                await update(matchRef, updates);
                console.log("DEBUG: Firebase update completed successfully (processTurn).");
                // Le onValue listener va détecter ce changement et mettre à jour l'UI
                // et potentiellement déclencher le timer pour le prochain tour.
            } catch (error) {
                console.error("DEBUG: ERROR during Firebase update in processTurn:", error);
                // Si l'update échoue, vous voudrez peut-être gérer une erreur côté utilisateur
                showMessage("action-msg", "Erreur critique lors du traitement du tour. Veuillez recharger la page.");
            }
        }


        // --- NOUVELLE FONCTION : Soumettre une action par défaut ---
        async function submitDefaultAction(playerKey, matchRef, currentMatchData) {
            if (!playerKey || !matchRef || !currentMatchData) return;

            // Double-vérifier que l'action n'a pas déjà été soumise pendant ce très court laps de temps
            if (currentMatchData.players[playerKey]?.action) {
                console.log(`Default action for ${playerKey} already submitted by another client.`);
                return;
            }

            const defaultAction = 'defend';
            const updates = {};
            updates[`players/${playerKey}/action`] = defaultAction;

            const newHistory = [...(currentMatchData.history || [])];
            const pseudo = currentMatchData.players[playerKey]?.pseudo || "Un joueur";
            newHistory.push(`${pseudo} n'a pas agi à temps et s'est automatiquement défendu.`);
            updates.history = newHistory;

            console.log(`DEBUG: Updates payload for default action (${playerKey}):`, JSON.stringify(updates, null, 2)); // Log added

            try {
                await update(matchRef, updates);
                console.log(`DEBUG: Default action '${defaultAction}' submitted for ${pseudo} (${playerKey}) due to timeout. Firebase update successful.`); // Log added
            } catch (error) {
                console.error(`DEBUG: ERROR submitting default action for ${playerKey}:`, error); // Log added
                // Ne pas afficher de message d'erreur à l'utilisateur, car cela peut se produire en arrière-plan
            }
        }

        // --- NOUVELLE FONCTION : Logique de l'IA ---
        async function aiTurn(playerPV, aiPV, matchRef) {
            console.log("[aiTurn] AI Turn: Player PV:", playerPV, "AI PV:", aiPV);
            let aiAction = 'defend'; // Action par défaut

            // Logique simple de l'IA
            if (aiPV < 30 && playerPV > 0) { // Si l'IA a peu de PV et le joueur est encore en vie
                aiAction = 'heal';
                console.log("[aiTurn] AI chose to HEAL.");
            } else if (playerPV < 40 && aiPV > 0) { // Si le joueur a peu de PV et l'IA est encore en vie
                aiAction = 'attack';
                console.log("[aiTurn] AI chose to ATTACK.");
            } else {
                // Choix aléatoire entre attaque et défense
                const actions = ['attack', 'defend'];
                aiAction = actions[Math.floor(Math.random() * actions.length)];
                console.log("[aiTurn] AI chose randomly:", aiAction);
            }

            // Soumettre l'action de l'IA à Firebase
            const updates = {};
            updates[`players/p2/action`] = aiAction; // L'IA est toujours p2

            // Fetch latest history to append
            const currentMatchSnapshot = await get(matchRef);
            const currentMatchData = currentMatchSnapshot.val();
            const newHistory = [...(currentMatchData.history || [])];
            newHistory.push(`L'IA a choisi : ${aiAction === 'attack' ? 'Attaque' : (aiAction === 'defend' ? 'Défense' : 'Soin')}.`);
            updates.history = newHistory;

            console.log("DEBUG: AI submitting action:", aiAction, "Payload:", JSON.stringify(updates, null, 2));
            try {
                await update(matchRef, updates);
                console.log("DEBUG: AI action submitted successfully.");
            } catch (error) {
                console.error("DEBUG: Error submitting AI action:", error);
            }
        }


        // --- ACTIONS DU JOUEUR ---
        async function performAction(actionType) {
            // Vérifier d'abord si hasPlayedThisTurn est VRAI avant de faire le get.
            // Si c'est déjà true, c'est que le joueur a déjà soumis son action pour ce tour.
            if (hasPlayedThisTurn) {
                showMessage("action-msg", "Vous avez déjà soumis une action pour ce tour.");
                console.log("Action blocked: already played this turn (hasPlayedThisTurn is true).");
                return;
            }
            if (!currentMatchId || !currentUser) {
                console.log("Action blocked: No match or no user.");
                return;
            }
            console.log(`Attempting to perform action: ${actionType}`);

            const matchRef = ref(db, `matches/${currentMatchId}`);
            const matchSnapshot = await get(matchRef);
            const matchData = matchSnapshot.val();

            if (!matchData) {
                showMessage("action-msg", "Match introuvable ou terminé.");
                backToMenu(true);
                console.log("Match not found for action.");
                return;
            }

            let playerKeyInMatch;
            if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                playerKeyInMatch = "p1";
            } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                playerKeyInMatch = "p2";
            } else {
                showMessage("action-msg", "Erreur: Votre rôle dans le match est indéterminé.");
                console.error("Player key in match not found for current user.");
                return;
            }

            if (matchData.turn !== playerKeyInMatch) {
                showMessage("action-msg", "Ce n'est pas votre tour !");
                console.log("Not player's turn to act.");
                return;
            }

            // Vérifier si l'action a déjà été enregistrée dans Firebase pour ce tour
            // C'est une double-vérification avec hasPlayedThisTurn, mais importante pour la robustesse.
            if (matchData.players[playerKeyInMatch].action) {
                 showMessage("action-msg", "Vous avez déjà soumis une action pour ce tour (vérification Firebase).");
                 console.log("Action already submitted for this turn (Firebase check).");
                 hasPlayedThisTurn = true; // S'assurer que hasPlayedThisTurn est à true
                 disableActionButtons(true); // Et les boutons désactivés
                 return;
            }

            // Enregistrer l'action dans Firebase
            const updates = {};
            updates[`players/${playerKeyInMatch}/action`] = actionType;

            const actionDisplayName = {
                'attack': 'Attaquer',
                'defend': 'Défendre',
                'heal': 'Soigner'
            }[actionType];

            actionMsgEl.textContent = `Vous avez choisi : ${actionDisplayName}. En attente de l'adversaire...`;
            console.log(`Submitting action '${actionType}' for ${currentUser.pseudo} (${playerKeyInMatch}).`);

            try {
                await update(matchRef, updates);
                hasPlayedThisTurn = true; // Marquer comme joué pour ce tour sur le client
                disableActionButtons(true);
                if (timerInterval) {
                    clearInterval(timerInterval); // Arrêter le timer une fois l'action soumise
                    timerInterval = null;
                    console.log("Timer interval cleared (action submitted by player)."); // Log added
                }
                console.log(`Action '${actionType}' submitted by ${currentUser.pseudo}. Timer stopped.`);
            } catch (error) {
                console.error("Error performing action:", error);
                showMessage("action-msg", "Erreur lors de l'envoi de votre action.");
            }
        }

        attackBtn.onclick = () => performAction('attack');
        defendBtn.onclick = () => performAction('defend');
        healBtn.onclick = () => performAction('heal');


        // --- MISE À JOUR DES STATISTIQUES UTILISATEUR ---
        async function updateUserStats(result) {
            if (!currentUser || !currentUser.pseudo) return;

            const userStatsRef = ref(db, `users/${currentUser.pseudo}`);
            try {
                const snapshot = await get(userStatsRef);
                if (snapshot.exists()) {
                    let { wins, losses } = snapshot.val();
                    wins = wins || 0;
                    losses = losses || 0;

                    if (result === 'win') {
                        wins++;
                    } else if (result === 'loss') {
                        losses++;
                    }
                    // 'draw' n'affecte pas les wins/losses ici

                    await update(userStatsRef, { wins, losses });
                    console.log(`Stats for ${currentUser.pseudo} updated: Wins=${wins}, Losses=${losses}`);
                }
            } catch (error) {
                console.error("Error updating user stats:", error);
            }
        }

        // --- GESTION DE LA FIN DE PARTIE ---
        async function handleGameEnd(data, youKeyPlayed, opponentKeyPlayed, finalResult) {
            console.log(`handleGameEnd called. Final result: ${finalResult}`);
            disableActionButtons(true);
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                console.log("Timer interval cleared (game end)."); // Log added
            }
            if (onDisconnectRef) {
                onDisconnectRef.cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                onDisconnectRef = null;
            }

            let finalMessage = "";
            let yourResultForStats = finalResult; // Default, will be updated for forfeit

            if (finalResult === 'win') {
                finalMessage = `Victoire ! Vous avez gagné le match contre ${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'l\'adversaire'} !`;
            } else if (finalResult === 'loss') {
                finalMessage = `Défaite... Vous avez perdu contre ${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'l\'adversaire'}.`;
            } else if (finalResult === 'draw') {
                finalMessage = "Match Nul ! Personne n'a gagné.";
            } else if (finalResult === 'forfeit_win') { // Forfeit win by opponent disconnect
                 finalMessage = `Victoire par forfait ! L'adversaire (${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'inconnu'}) s'est déconnecté.`;
                 yourResultForStats = 'win';
            } else if (finalResult === 'forfeit_loss') { // Forfeit loss by your own disconnect (less common but possible)
                 finalMessage = "Vous avez perdu par forfait (déconnexion).";
                 yourResultForStats = 'loss';
            }
            else {
                finalMessage = "Le match est terminé.";
            }

            actionMsgEl.textContent = finalMessage;
            updateUserStats(yourResultForStats); // Mettre à jour les stats

            if (!matchDeletionTimeout) {
                actionMsgEl.textContent += " Retour au menu dans 10 secondes...";
                matchDeletionTimeout = setTimeout(async () => {
                    console.log(`Match ${currentMatchId} ended, attempting cleanup.`);
                    // Seul P1 (le créateur) ou un client avec la certitude que l'adversaire est parti
                    // devrait tenter de supprimer le match. Pour un duel, P1 est un bon candidat.
                    // Si le match est à 'forfeited' et que youKey est le gagnant par forfait, il peut aussi nettoyer.
                    const matchRef = ref(db, `matches/${currentMatchId}`);
                    const snapshot = await get(matchRef);
                    const currentData = snapshot.val();

                    if (currentData && (currentData.status === 'finished' || currentData.status === 'forfeited')) {
                         // Only the winner (if applicable) or P1 tries to delete.
                         // Or if the match is already forfeited and it was this client who caused it (via onDisconnect).
                         const shouldDelete = (youKeyPlayed === 'p1') ||
                                              (currentData.status === 'forfeited' && currentData.winner === youKeyPlayed);

                         if (shouldDelete) {
                             try {
                                 await remove(matchRef);
                                 console.log(`Match ${currentMatchId} removed.`);
                             } catch (err) {
                                 console.error("Error removing finished match:", err);
                             }
                         } else {
                             console.log(`Client ${youKeyPlayed} (not P1 or not winner of forfeit) skipping match deletion.`);
                         }
                    } else {
                        console.log("Match already deleted or status changed before deletion attempt.");
                    }
                    backToMenu(true);
                    matchDeletionTimeout = null;
                }, 10000);
            }
        }


        // --- RETOUR AU MENU ---
        function backToMenu(force = false) {
            console.log(`Returning to menu (force: ${force}). Current Match ID: ${currentMatchId}`);
            // Nettoyage complet
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
                console.log("Match listener unsubscribed.");
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                console.log("Timer interval cleared (back to menu)."); // Log added
            }
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
                console.log("Match deletion timeout cleared.");
            }
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
                console.log("Match creation listener unsubscribed.");
            }
            if (onDisconnectRef) { // Annuler onDisconnect si défini
                onDisconnectRef.cancel().then(() => {
                    console.log("onDisconnect operation cancelled.");
                }).catch(err => {
                    console.error("Error canceling onDisconnect on backToMenu:", err);
                });
                onDisconnectRef = null;
            }

            // Gérer le forfait si le joueur quitte un match en cours volontairement
            if (currentMatchId && currentUser && !force && gameMode === 'PvP') { // Seulement pour PvP
                const matchRef = ref(db, `matches/${currentMatchId}`);
                console.log(`Attempting to forfeit match ${currentMatchId} for ${currentUser.pseudo}.`);
                get(matchRef).then(snapshot => {
                    const matchData = snapshot.val();
                    // Vérifier si le match est toujours "playing" et que le joueur y est
                    if (matchData && matchData.status === 'playing') {
                        let quitterKey = null;
                        let opponentKeyForForfeit = null;

                        if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                            quitterKey = "p1"; opponentKeyForForfeit = "p2";
                        } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                            quitterKey = "p2"; opponentKeyForForfeit = "p1";
                        }

                        // S'assurer que le joueur est bien dans le match et qu'il y a un adversaire actif
                        if (quitterKey && matchData.players[opponentKeyForForfeit] && matchData.players[opponentKeyForForfeit].status === 'connected') {
                            const updates = {};
                            updates[`players/${quitterKey}/pv`] = 0;
                            updates[`players/${quitterKey}/status`] = 'forfeited';
                            updates.status = 'forfeited';
                            updates.winner = opponentKeyForForfeit;
                            updates.history = [...(matchData.history || [])]; // Copie l'historique existant
                            updates.history.push(`${currentUser.pseudo} a quitté le match. ${matchData.players[opponentKeyForForfeit].pseudo} gagne par forfait.`);

                            update(matchRef, updates)
                                .then(() => console.log(`${currentUser.pseudo} left and forfeited match ${currentMatchId}`))
                                .catch(err => console.error("Error updating match on forfeit:", err));
                        } else {
                            console.log("Not in a playing match or opponent not connected for forfeit logic.");
                        }
                    } else {
                        console.log("Match not in 'playing' status or data missing for voluntary forfeit.");
                    }
                }).catch(err => console.error("Error getting match for backToMenu forfeit:", err));
            }

            currentMatchId = null;
            hasPlayedThisTurn = false;
            youKey = null; // Réinitialiser
            opponentKey = null; // Réinitialiser
            gameMode = 'PvP'; // Réinitialiser le mode de jeu à PvP par défaut

            showMessage("action-msg", "");
            showMessage("match-msg", "");
            if (opponentActionStatusEl) opponentActionStatusEl.textContent = "";

            document.getElementById("game").style.display = "none";
            document.getElementById("match").style.display = "block";

            matchIdInput.value = "";
        }

        backToMenuBtn.onclick = () => backToMenu();

        // Initialiser l'affichage
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById("auth").style.display = "block";
        });
    </script>
</body>
</html>
