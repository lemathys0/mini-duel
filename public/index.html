<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Duel de Cartes</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #4a6a8c);
            color: #ecf0f1;
            /* Corrections pour le défilement */
            min-height: 100vh;
            margin: 0;
            overflow-y: auto; /* Permet le défilement vertical si le contenu dépasse */
            position: relative;
            padding: 20px; /* Ajoute un peu de padding pour ne pas coller les bords */
            box-sizing: border-box; /* Assurez-vous que le padding est inclus dans la largeur/hauteur */
            display: flex; /* Garde le flex pour le centrage horizontal du container */
            justify-content: center; /* Centre horizontalement */
            /* align-items: center; /* COMMENTÉ pour permettre le défilement vertical */
        }

        .container {
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%;
            max-width: 600px;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 1;
            margin: 0 auto; /* Centre le conteneur horizontalement */
            margin-bottom: 50px; /* Pour un peu d'espace en bas si l'écran est petit */
        }

        h1 {
            color: #e74c3c; /* Rouge pour le titre */
            margin-bottom: 25px;
            font-size: 2.5em;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
        }

        h2 {
            color: #f1c40f; /* Jaune pour les sous-titres */
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        input[type="text"],
        input[type="password"] {
            width: calc(100% - 20px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #34495e;
            border-radius: 8px;
            background-color: #1a252f;
            color: #ecf0f1;
            font-size: 1em;
            box-sizing: border-box;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: #5d6d7e;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .message {
            margin-top: 15px;
            font-weight: bold;
            min-height: 20px;
            color: #ff4d6d; /* Default for errors */
        }
        .message[style*="00ff88"] { /* Specific color for success */
            color: #00ff88;
        }

        #auth, #match, #game {
            display: none;
        }

        #game {
            text-align: left;
        }

        .player-info {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            background: rgba(44, 62, 80, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-info.you {
            background: rgba(39, 174, 96, 0.3); /* Vert pour le joueur */
        }

        .player-info.opponent {
            background: rgba(231, 76, 60, 0.3); /* Rouge pour l'adversaire */
        }

        .player-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #ecf0f1;
            flex-grow: 1;
        }

        .health-bar-container {
            width: 150px;
            height: 20px;
            background-color: #34495e;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-left: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .health-bar {
            height: 100%;
            width: 100%; /* Start full */
            background-color: var(--heal, #2ecc71); /* Default green */
            transition: width 0.5s ease-out, background-color 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .health-bar.low {
            background-color: var(--warning, #f1c40f); /* Orange */
        }

        .health-bar.critical {
            background-color: var(--danger, #e74c3c); /* Red */
        }

        /* Health bar effects */
        .health-bar.damage-effect {
            animation: flashRed 0.3s ease-in-out;
        }

        .health-bar.heal-effect {
            animation: flashGreen 0.6s ease-in-out;
        }

        @keyframes flashRed {
            0% { background-color: #e74c3c; }
            50% { background-color: #f06292; } /* Brighter red */
            100% { background-color: var(--danger, #e74c3c); } /* Back to current color */
        }

        @keyframes flashGreen {
            0% { background-color: #2ecc71; }
            50% { background-color: #a7f7b7; } /* Lighter green */
            100% { background-color: var(--heal, #2ecc71); } /* Back to current color */
        }


        .pv-display {
            margin-left: 10px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .game-controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-controls p {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #ecf0f1;
            min-height: 25px; /* Pour éviter le saut de layout */
        }
        
        .timer-container {
            display: flex;
            align-items: center;
            margin-top: 15px;
            margin-bottom: 20px;
            background-color: #1a252f;
            border-radius: 8px;
            padding: 10px;
        }

        .timer-label {
            font-weight: bold;
            margin-right: 10px;
            color: #f39c12; /* Jaune-orange */
        }

        .timer-bar-wrapper {
            flex-grow: 1;
            height: 15px;
            background-color: #5d6d7e;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .timer-progress-bar {
            height: 100%;
            width: 100%; /* Starts full */
            background-color: #2ecc71; /* Green */
            transition: width 0.5s linear, background-color 0.5s linear;
        }

        .timer-value {
            margin-left: 10px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .history-section {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-section p {
            margin: 5px 0;
            font-size: 0.9em;
            color: #bdc3c7;
        }

        .history-section p:last-child {
            font-weight: bold;
            color: #ecf0f1;
        }
        
        /* Background animation (optional) */
        .bg-shapes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            pointer-events: none;
        }

        .bg-shapes div {
            position: absolute;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            animation: moveShape 10s infinite alternate;
        }

        .bg-shapes div:nth-child(1) { width: 60px; height: 60px; top: 10%; left: 20%; animation-duration: 12s; }
        .bg-shapes div:nth-child(2) { width: 100px; height: 100px; top: 50%; left: 80%; animation-duration: 15s; }
        .bg-shapes div:nth-child(3) { width: 40px; height: 40px; top: 80%; left: 40%; animation-duration: 10s; }
        .bg-shapes div:nth-child(4) { width: 80px; height: 80px; top: 30%; left: 10%; animation-duration: 13s; }
        .bg-shapes div:nth-child(5) { width: 70px; height: 70px; top: 60%; left: 60%; animation-duration: 11s; }

        @keyframes moveShape {
            0% { transform: translate(0, 0) scale(1); opacity: 0.05; }
            100% { transform: translate(20px, 30px) scale(1.1); opacity: 0.08; }
        }

    </style>
</head>
<body>
    <div class="bg-shapes">
        <div></div><div></div><div></div><div></div><div></div>
    </div>
    
    <div class="container">
        <h1>Mini Duel de Cartes</h1>

        <div id="auth">
            <h2>Authentification</h2>
            <input type="text" id="pseudo" placeholder="Votre Pseudo">
            <input type="password" id="code" placeholder="Votre Code (4 chiffres)">
            <button id="login-btn">Se Connecter</button>
            <button id="signup-btn">S'inscrire</button>
            <p id="auth-msg" class="message"></p>
        </div>

        <div id="match">
            <h2>Bienvenue <span id="player-name" style="color:#f1c40f;"></span> !</h2>
            <h3>Rejoindre ou Créer un Match</h3>
            <input type="text" id="match-id" placeholder="Code du Match (ex: ABC123)">
            <button id="join-match-btn">Rejoindre Match</button>
            <button id="create-match-btn">Créer Match</button>
            <p id="match-msg" class="message"></p>
        </div>

        <div id="game">
            <h2>Match: <span id="current-match" style="color:#f1c40f;"></span></h2>

            <div class="player-info you">
                <span id="you-name" class="player-name">Vous</span>
                <span class="pv-display" id="you-pv-display">100</span>
                <div class="health-bar-container">
                    <div class="health-bar" id="you-health-bar"></div>
                </div>
            </div>

            <div class="player-info opponent">
                <span id="opponent-name" class="player-name">Adversaire</span>
                <span class="pv-display" id="opponent-pv-display">100</span>
                <div class="health-bar-container">
                    <div class="health-bar" id="opponent-health-bar"></div>
                </div>
                <span id="opponent-action-status" style="margin-left: 20px; font-size: 0.9em; color: #bbb;"></span>
            </div>
            
            <div class="timer-container">
                <span class="timer-label">Temps restant:</span>
                <div class="timer-bar-wrapper">
                    <div class="timer-progress-bar" id="timer-progress-bar"></div>
                </div>
                <span class="timer-value" id="timer-value">20</span>
            </div>

            <div class="game-controls">
                <p id="action-msg" class="message"></p>
                <button id="attack-btn">Attaquer (10 dégâts)</button>
                <button id="defend-btn">Défendre (-5 dégâts reçus)</button>
                <button id="heal-btn">Soigner (+15 PV)</button>
            </div>

            <div class="history-section">
                <h3>Historique du match</h3>
                <div id="history">
                    </div>
            </div>
            <button id="back-to-menu-btn" style="margin-top: 20px; background-color: #9b59b6;">Retour au Menu</button>
        </div>
    </div>

    <script type="module">
        // Import Firebase (corrected paths)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, update, push, child, remove, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";
        
        // --- CONFIGURATION FIREBASE ---
        const firebaseConfig = {
            apiKey: "YOUR_FIREBASE_API_KEY", // REMPLACEZ PAR VOTRE VRAIE CLÉ API
            authDomain: "mini-duel-de-cartes.firebaseapp.com",
            databaseURL: "https://mini-duel-de-cartes-default-rtdb.firebaseio.com",
            projectId: "mini-duel-de-cartes",
            storageBucket: "mini-duel-de-cartes.appspot.com", 
            messagingSenderId: "1084207708579",
            appId: "1:1084207708579:web:f1312b68b7eb08f9d44216",
            measurementId: "G-7YW3J41XZF" 
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- VARIABLES GLOBALES ---
        let currentUser = null; // { pseudo, code }
        let currentMatchId = null; 
        // hasPlayedThisTurn : Vrai si le joueur a soumis son action pour le tour ACTUEL.
        // Cette variable est essentielle pour éviter de soumettre plusieurs actions par tour.
        // Elle sera réinitialisée uniquement lorsque le tour est processé par le P1.
        let hasPlayedThisTurn = false; 
        let timerInterval = null;
        const timerMax = 20; // secondes (réduit le temps pour un jeu plus rapide)
        let timerCount = timerMax;
        let youKey = null; // 'p1' or 'p2' for the current user in the match
        let opponentKey = null; // 'p1' or 'p2' for the opponent

        let unsubscribeMatchCreationListener = null; 
        let matchDeletionTimeout = null; 
        let currentMatchUnsubscribe = null; 
        let onDisconnectRef = null; // To store the onDisconnect reference for proper cancellation

        // --- DOM Elements Cache ---
        const pseudoInput = document.getElementById("pseudo");
        const codeInput = document.getElementById("code");
        const authMsgEl = document.getElementById("auth-msg");
        const matchIdInput = document.getElementById("match-id");
        const matchMsgEl = document.getElementById("match-msg");
        const actionMsgEl = document.getElementById("action-msg");
        const youPvDisplayEl = document.getElementById("you-pv-display");
        const opponentPvDisplayEl = document.getElementById("opponent-pv-display");
        const youHealthBarEl = document.getElementById("you-health-bar");
        const opponentHealthBarEl = document.getElementById("opponent-health-bar");
        const timerValueEl = document.getElementById("timer-value");
        const timerProgressBarEl = document.getElementById("timer-progress-bar");
        const attackBtn = document.getElementById("attack-btn");
        const defendBtn = document.getElementById("defend-btn");
        const healBtn = document.getElementById("heal-btn");
        const backToMenuBtn = document.getElementById("back-to-menu-btn");
        const opponentActionStatusEl = document.getElementById("opponent-action-status"); // Nouvel élément


        // --- FONCTIONS UTILITAIRES ---

        function showMessage(elementId, message, isSuccess = false) {
            const el = document.getElementById(elementId);
            if (el) {
                el.style.color = isSuccess ? "#00ff88" : "#ff4d6d";
                el.textContent = message;
                // Efface le message après un court délai s'il s'agit d'un message temporaire
                if (!isSuccess) {
                    setTimeout(() => {
                        if (el.textContent === message) el.textContent = "";
                    }, 5000); 
                }
            }
        }

        function disableActionButtons(disabled) {
            attackBtn.disabled = disabled;
            defendBtn.disabled = disabled;
            healBtn.disabled = disabled;
        }
        
        function updateHealthBar(healthBarElement, pvDisplayElement, currentPV, isOpponent = false) {
            const percentage = Math.max(0, Math.min(100, currentPV));
            healthBarElement.style.width = `${percentage}%`;
            healthBarElement.textContent = `${Math.round(percentage)}%`; // Arrondi le pourcentage

            // Ajout d'une animation si les PV ont changé (visuel)
            const oldPV = parseInt(pvDisplayElement.textContent);
            if (currentPV < oldPV) { // Dégâts
                healthBarElement.classList.add('damage-effect');
                setTimeout(() => healthBarElement.classList.remove('damage-effect'), 500);
            } else if (currentPV > oldPV) { // Soin
                healthBarElement.classList.add('heal-effect');
                setTimeout(() => healthBarElement.classList.remove('heal-effect'), 1000);
            }

            pvDisplayElement.textContent = currentPV;

            healthBarElement.classList.remove('low', 'critical');
            // Gérer les couleurs pour sa propre barre de vie et celle de l'adversaire
            if (isOpponent) {
                healthBarElement.style.backgroundColor = `var(--danger)`; // Rouge pour l'adversaire
            } else if (currentPV < 10) {
                healthBarElement.classList.add('critical');
            } else if (currentPV < 30) {
                healthBarElement.classList.add('low');
            } else {
                healthBarElement.style.backgroundColor = `var(--heal)`; // Vert par défaut
            }
        }

        function updateTimerUI(value) {
            timerValueEl.textContent = value;
            const progress = (value / timerMax) * 100;
            timerProgressBarEl.style.width = `${progress}%`;
            // Interpolation de couleur du vert au rouge
            const r = Math.min(255, Math.floor((100 - progress) * 2.55 * 2)); 
            const g = Math.min(255, Math.floor(progress * 2.55 * 2)); 
            timerProgressBarEl.style.backgroundColor = `rgb(${r}, ${g}, 0)`; 
        }


        // --- AUTHENTIFICATION ---

        document.getElementById("signup-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (pseudo.length < 2) {
                showMessage("auth-msg", "Pseudo trop court (min 2 caractères).");
                return;
            }
            if (!/^\d{4}$/.test(code)) {
                showMessage("auth-msg", "Code doit être composé de 4 chiffres.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("auth-msg", "Ce pseudo est déjà pris.");
                } else {
                    set(userRef, { code, wins: 0, losses: 0, createdAt: serverTimestamp() })
                        .then(() => {
                            showMessage("auth-msg", "Inscription réussie !", true);
                            currentUser = { pseudo, code };
                            afterLogin();
                        })
                        .catch(error => {
                            console.error("Signup error:", error);
                            showMessage("auth-msg", "Erreur lors de l'inscription.");
                        });
                }
            }).catch(error => {
                console.error("Checking user for signup error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("login-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (!pseudo || !code) {
                showMessage("auth-msg", "Pseudo et code requis.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("auth-msg", "Pseudo inconnu.");
                } else {
                    const data = snapshot.val();
                    if (data.code === code) {
                        showMessage("auth-msg", "Connexion réussie !", true);
                        currentUser = { pseudo, code };
                        afterLogin();
                    }
                    else {
                        showMessage("auth-msg", "Code incorrect.");
                    }
                }
            }).catch(error => {
                console.error("Login error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        function afterLogin() {
            document.getElementById("auth").style.display = "none";
            document.getElementById("match").style.display = "block";
            document.getElementById("player-name").textContent = currentUser.pseudo;
            showMessage("auth-msg", ""); // Clear auth message
            pseudoInput.value = ""; // Clear inputs
            codeInput.value = "";
        }

        // --- MATCH ---

        document.getElementById("create-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code pour le match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("match-msg", "Ce code de match est déjà utilisé.");
                } else {
                    const initialMatchData = {
                        players: {
                            p1: { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null },
                            p2: null
                        },
                        turn: "p1", // Initial turn
                        history: [`Match ${matchId} créé par ${currentUser.pseudo}. En attente d'un adversaire...`],
                        status: "waiting", // waiting, playing, finished, forfeited
                        createdAt: serverTimestamp(),
                        lastTurnProcessedAt: serverTimestamp() // Timestamp to help sync timer across clients
                    };
                    set(matchRef, initialMatchData).then(() => {
                        showMessage("match-msg", "Match créé. En attente de l'adversaire...", true);
                        startMatchMonitoring(matchId); 

                        // Cleanup listener for unjoined match - improved
                        if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); // Clear previous
                        unsubscribeMatchCreationListener = onValue(matchRef, (matchSnapshot) => {
                            const matchData = matchSnapshot.val();
                            if (!matchData) { // Match was deleted
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                                return;
                            }
                            if (matchData.status === 'waiting' && !matchData.players.p2 && matchData.createdAt) {
                                const timeElapsed = Date.now() - matchData.createdAt;
                                if (timeElapsed > 60000) { // 1 minute timeout for waiting match
                                    console.log(`Match ${matchId} non rejoint après 1 minute, suppression.`);
                                    remove(matchRef)
                                        .then(() => {
                                            showMessage("match-msg", "Match expiré et supprimé (aucun adversaire).");
                                            if (currentMatchId === matchId) { 
                                                backToMenu(true); 
                                            }
                                        })
                                        .catch(err => console.error("Error removing expired match:", err));
                                    if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); 
                                    unsubscribeMatchCreationListener = null;
                                }
                            } else if (matchData.players.p2 && matchData.status === 'playing') { // Opponent joined
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                            }
                        });

                    }).catch(error => {
                        console.error("Error creating match:", error);
                        showMessage("match-msg", "Erreur lors de la création du match.");
                    });
                }
            }).catch(error => {
                console.error("Error checking match existence:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("join-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code de match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("match-msg", "Ce match n'existe pas.");
                    return;
                }

                const matchData = snapshot.val();
                if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                    showMessage("match-msg", "Vous êtes déjà le créateur de ce match. Attendez un joueur.");
                    startMatchMonitoring(matchId); 
                    return;
                }
                if (matchData.players.p2) {
                    showMessage("match-msg", "Ce match est déjà complet.");
                    return;
                }
                if (matchData.status !== 'waiting') {
                    showMessage("match-msg", "Ce match n'est plus en attente de joueurs.");
                    return;
                }
                
                const updates = {};
                updates[`players/p2`] = { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null };
                updates[`status`] = 'playing';
                updates[`history`] = [...(matchData.history || []), `${currentUser.pseudo} a rejoint le match ! Le duel commence.`];
                updates[`lastTurnProcessedAt`] = serverTimestamp(); // Sync timer on join

                update(matchRef, updates).then(() => {
                    showMessage("match-msg", "Vous avez rejoint le match !", true);
                    startMatchMonitoring(matchId);
                }).catch(error => {
                    console.error("Error joining match:", error);
                    showMessage("match-msg", "Erreur pour rejoindre le match.");
                });
            }).catch(error => {
                console.error("Error getting match to join:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };
        
        // --- DÉBUT ET SUIVI DU MATCH ---
        function startMatchMonitoring(id) {
            // Nettoyage des listeners précédents
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe(); 
                currentMatchUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (onDisconnectRef) {
                onDisconnectRef.cancel().catch(err => console.error("Error canceling old onDisconnect:", err));
                onDisconnectRef = null;
            }
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
            }
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
            }

            currentMatchId = id;
            const matchRef = ref(db, `matches/${id}`);

            document.getElementById("match").style.display = "none";
            document.getElementById("game").style.display = "block";
            document.getElementById("current-match").textContent = id;
            document.getElementById("you-name").textContent = currentUser.pseudo;
            document.getElementById("history").innerHTML = ""; // Clear history on new match start
            if (opponentActionStatusEl) opponentActionStatusEl.textContent = ""; // Clear opponent status

            // IMPORTANT : Réinitialiser hasPlayedThisTurn au début d'un nouveau match
            hasPlayedThisTurn = false; 
            disableActionButtons(true); // Initialisation: boutons désactivés
            actionMsgEl.textContent = "Chargement du match...";

            currentMatchUnsubscribe = onValue(matchRef, async (snapshot) => {
                console.log("onValue triggered:", snapshot.val()); // Pour le débogage
                const data = snapshot.val();
                if (!data) {
                    // Match supprimé ou inexistant
                    if (currentMatchId === id) { 
                        showMessage("action-msg", "Le match a été terminé ou supprimé.");
                        if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                        currentMatchUnsubscribe = null;
                        setTimeout(() => backToMenu(true), 3000);
                    }
                    return;
                }
                
                // Déterminer le rôle du joueur actuel (p1 ou p2)
                let you, opponent;
                if (data.players.p1 && data.players.p1.pseudo === currentUser.pseudo) {
                    you = data.players.p1; youKey = "p1";
                    opponent = data.players.p2; opponentKey = "p2";
                } else if (data.players.p2 && data.players.p2.pseudo === currentUser.pseudo) {
                    you = data.players.p2; youKey = "p2";
                    opponent = data.players.p1; opponentKey = "p1";
                } else {
                    // N'est pas un joueur dans ce match (ex: a été déconnecté/kické)
                    actionMsgEl.textContent = "Vous n'êtes pas un joueur dans ce match.";
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    return;
                }
                
                // Mettre à jour lastSeen et définir onDisconnect
                const yourPlayerRef = ref(db, `matches/${id}/players/${youKey}`);
                if (!onDisconnectRef) { // Set onDisconnect only once per match
                    onDisconnectRef = onDisconnect(yourPlayerRef);
                    onDisconnectRef.update({
                        pv: 0, 
                        status: 'disconnected',
                        lastSeen: serverTimestamp() 
                    }).catch(error => console.error("Error setting onDisconnect:", error));
                }
                // Mise à jour régulière de lastSeen pour signaler la présence
                update(yourPlayerRef, { lastSeen: serverTimestamp(), status: 'connected' }); 

                // Mettre à jour l'interface avec les données des joueurs
                updateHealthBar(youHealthBarEl, youPvDisplayEl, you.pv);
                document.getElementById("you-name").textContent = `${you.pseudo} (Vous)`;

                let opponentActionStatus = "En attente d'action...";
                if (opponent) {
                    updateHealthBar(opponentHealthBarEl, opponentPvDisplayEl, opponent.pv, true); // true pour l'adversaire
                    document.getElementById("opponent-name").textContent = opponent.pseudo;
                    // Afficher si l'adversaire a soumis son action
                    if (opponent.action) {
                        opponentActionStatus = "Action soumise !";
                    } else {
                        opponentActionStatus = "En attente d'action...";
                    }
                } else {
                    opponentPvDisplayEl.textContent = "N/A";
                    opponentHealthBarEl.style.width = "0%";
                    opponentHealthBarEl.textContent = "0%";
                    document.getElementById("opponent-name").textContent = "En attente...";
                    opponentActionStatus = "En attente d'un adversaire...";
                }
                if (opponentActionStatusEl) opponentActionStatusEl.textContent = opponentActionStatus;
                
                // Si en attente du P2 ou si P2 est déconnecté/forfait
                if (data.status === "waiting" || !opponent || opponent.status === 'disconnected' || opponent.status === 'forfeited') {
                    if (opponent && (opponent.status === 'disconnected' || opponent.status === 'forfeited')) {
                        actionMsgEl.textContent = `L'adversaire (${opponent.pseudo}) est déconnecté. Le match est terminé.`;
                        handleGameEnd(data, youKey, opponentKey, 'win'); // You win by forfeit
                    } else {
                        actionMsgEl.textContent = "En attente de l'adversaire...";
                    }
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    updateTimerUI(timerMax); // Reset timer display
                    return;
                }
                
                // Conditions de fin de jeu (après avoir géré l'attente)
                if (data.status === 'finished' || you.pv <= 0 || opponent.pv <= 0) {
                    // Unsubscribe onDisconnect as match is ending
                    if (onDisconnectRef) {
                        onDisconnectRef.cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                        onDisconnectRef = null;
                    }

                    let finalResult = "draw";
                    if (you.pv > 0 && opponent.pv <= 0) {
                        finalResult = "win";
                    } else if (you.pv <= 0 && opponent.pv > 0) {
                        finalResult = "loss";
                    }
                    handleGameEnd(data, youKey, opponentKey, finalResult);
                    return; 
                }

                // Logs pour le débogage des actions
                console.log("P1 action:", data.players.p1?.action, "P2 action:", data.players.p2?.action);

                // Gérer les actions si c'est le tour actuel et que les deux actions sont là
                // SEULEMENT le joueur P1 (le créateur du match) est désigné pour traiter les actions
                // pour éviter les courses et les boucles de mise à jour.
                if (data.players.p1.action && data.players.p2.action) {
                    console.log("Both actions are present.");
                    // Réinitialiser hasPlayedThisTurn pour les deux joueurs quand les deux actions sont là
                    // car cela signifie que le tour va être traité.
                    hasPlayedThisTurn = false; 

                    if (youKey === 'p1') { // Seul P1 traite le tour
                        console.log("P1 detected both actions, will process turn.");
                        setTimeout(() => { // Augmenté le délai pour la stabilité
                            get(matchRef).then(latestSnapshot => {
                                const latestData = latestSnapshot.val();
                                if (latestData && latestData.players.p1.action && latestData.players.p2.action) {
                                    console.log("P1 proceeding to call processTurn with latest data.");
                                    processTurn(latestData, youKey, opponentKey, matchRef);
                                } else {
                                    console.log("Actions already processed or not present for P1 processing (after timeout).");
                                }
                            }).catch(err => console.error("Error getting latest match data for processing:", err));
                        }, 0); // Délai de 200 ms pour la propagation Firebase
                    } else {
                        console.log("P2 detected both actions, P1 is responsible for processing. Waiting for P1's update.");
                    }
                    // Le reste du onValue DOIT s'exécuter pour mettre à jour l'UI
                }


                // Gestion du Tour
                if (data.turn === youKey) {
                    // Si le joueur a déjà soumis son action, il attend l'adversaire
                    if (data.players[youKey].action) { // Vérifier l'état de l'action dans Firebase
                        disableActionButtons(true);
                        actionMsgEl.textContent = "Action jouée. En attente de l'adversaire...";
                        if (timerInterval) clearInterval(timerInterval); 
                        timerInterval = null;
                        console.log("Your turn, action played. Waiting for opponent.");
                    } else { // C'est votre tour et vous n'avez PAS encore joué
                        disableActionButtons(false);
                        actionMsgEl.textContent = "C'est votre tour ! Choisissez une action.";
                        if (!timerInterval) { 
                             // Synchroniser le timer avec la base de données
                            const elapsedSinceLastTurn = data.lastTurnProcessedAt ? (Date.now() - data.lastTurnProcessedAt) : 0;
                            const initialTimerValue = Math.max(0, timerMax - Math.floor(elapsedSinceLastTurn / 1000));
                            resetTimerAndStart(youKey, opponentKey, initialTimerValue);
                            console.log("Your turn, starting timer.");
                        } else {
                            console.log("Your turn, timer already running.");
                        }
                        // Important : Réinitialiser hasPlayedThisTurn ici aussi,
                        // car un nouveau tour vient de commencer pour ce joueur.
                        hasPlayedThisTurn = false; 
                    }
                } else { // Tour de l'adversaire
                    disableActionButtons(true);
                    actionMsgEl.textContent = `Tour de ${opponent ? opponent.pseudo : 'l\'adversaire'}. Veuillez patienter...`;
                    if (timerInterval) clearInterval(timerInterval); 
                    timerInterval = null;
                    // Ne pas réinitialiser hasPlayedThisTurn ici, il doit rester à false ou true
                    // jusqu'à ce que le tour du joueur revienne ou que le tour soit traité.
                    updateTimerUI(timerMax); // Afficher le timer plein pour l'adversaire (visuellement)
                    console.log("Opponent's turn. Waiting.");
                }

                // Mettre à jour l'historique
                const histEl = document.getElementById("history");
                histEl.innerHTML = ""; 
                (data.history || []).forEach(entry => {
                    const p = document.createElement("p");
                    p.textContent = entry;
                    histEl.appendChild(p);
                });
                histEl.scrollTop = histEl.scrollHeight; 

            }, (error) => {
                console.error("Error listening to match data:", error);
                showMessage("action-msg", "Erreur de connexion au match. Retour au menu.");
                if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
                setTimeout(() => backToMenu(true), 3000);
            });
        }

        // --- RESOLUTION DU TOUR ---
        async function processTurn(data, youKeyCurrentListener, opponentKeyCurrentListener, matchRef) {
            console.log("processTurn started (by P1 if logic is followed) with data:", JSON.stringify(data));
            
            // Vérifiez encore une fois que les actions sont non-nulles pour éviter le double traitement
            if (!data.players.p1.action || !data.players.p2.action) {
                console.warn("processTurn called but one or both actions are null. Exiting (already processed or not ready).");
                return; // Ne rien faire si les actions sont déjà effacées
            }

            if (timerInterval) {
                clearInterval(timerInterval); // Stop timer immediately when processing
                timerInterval = null;
            }
            disableActionButtons(true); // Disable buttons during processing

            // IMPORTANT : Réinitialiser hasPlayedThisTurn ici car le tour est sur le point d'être traité
            // Cela garantit que lorsque le nouveau tour commencera, le joueur pourra de nouveau jouer.
            hasPlayedThisTurn = false; 

            const p1Action = data.players.p1.action;
            const p2Action = data.players.p2.action;

            let p1PV = data.players.p1.pv;
            let p2PV = data.players.p2.pv;
            let historyUpdates = [...(data.history || [])];

            historyUpdates.push(`--- Début du tour ---`);
            
            // Logique d'application des actions
            // Attaque
            if (p1Action === 'attack') {
                historyUpdates.push(`${data.players.p1.pseudo} attaque !`);
                if (p2Action === 'defend') {
                    p2PV -= 5; 
                    historyUpdates.push(`${data.players.p2.pseudo} se défend, subit 5 PV de dégâts.`);
                } else {
                    p2PV -= 10; 
                    historyUpdates.push(`${data.players.p2.pseudo} subit 10 PV de dégâts.`);
                }
            }
            if (p2Action === 'attack') {
                historyUpdates.push(`${data.players.p2.pseudo} attaque !`);
                if (p1Action === 'defend') {
                    p1PV -= 5; 
                    historyUpdates.push(`${data.players.p1.pseudo} se défend, subit 5 PV de dégâts.`);
                } else {
                    p1PV -= 10; 
                    historyUpdates.push(`${data.players.p1.pseudo} subit 10 PV de dégâts.`);
                }
            }

            // Soin
            if (p1Action === 'heal') {
                p1PV = Math.min(100, p1PV + 15);
                historyUpdates.push(`${data.players.p1.pseudo} se soigne et récupère 15 PV.`);
            }
            if (p2Action === 'heal') {
                p2PV = Math.min(100, p2PV + 15);
                historyUpdates.push(`${data.players.p2.pseudo} se soigne et récupère 15 PV.`);
            }

            // Défense (déjà géré dans l'attaque, mais on peut loguer pour la clarté)
            if (p1Action === 'defend' && p2Action !== 'attack') {
                historyUpdates.push(`${data.players.p1.pseudo} se met en position défensive.`);
            }
            if (p2Action === 'defend' && p1Action !== 'attack') {
                historyUpdates.push(`${data.players.p2.pseudo} se met en position défensive.`);
            }

            historyUpdates.push(`--- Fin du tour ---`);

            // S'assurer que les PV ne sont pas négatifs
            p1PV = Math.max(0, p1PV);
            p2PV = Math.max(0, p2PV);

            // Déterminer le prochain tour ou la fin du match
            let nextTurn = (data.turn === 'p1') ? 'p2' : 'p1';
            let gameStatus = 'playing';
            let winner = null;
            let loser = null;

            if (p1PV <= 0 && p2PV <= 0) {
                gameStatus = "finished";
                winner = "draw";
                historyUpdates.push("Les deux joueurs sont à terre. C'est un match nul !");
            } else if (p1PV <= 0) {
                gameStatus = "finished";
                winner = "p2";
                loser = "p1";
                historyUpdates.push(`${data.players.p1.pseudo} est vaincu ! ${data.players.p2.pseudo} gagne le match.`);
            } else if (p2PV <= 0) {
                gameStatus = "finished";
                winner = "p1";
                loser = "p2";
                historyUpdates.push(`${data.players.p2.pseudo} est vaincu ! ${data.players.p1.pseudo} gagne le match.`);
            }

            const updates = {
                [`players/p1/pv`]: p1PV,
                [`players/p2/pv`]: p2PV,
                [`players/p1/action`]: null, // Réinitialise l'action du joueur 1 pour le prochain tour
                [`players/p2/action`]: null, // Réinitialise l'action du joueur 2 pour le prochain tour
                history: historyUpdates,
                turn: nextTurn,
                status: gameStatus,
                lastTurnProcessedAt: serverTimestamp() // Mettre à jour le timestamp pour le timer
            };

            if (winner) {
                updates.winner = winner;
                if (loser) updates.loser = loser;
            }

            console.log("Attempting to update Firebase with processed turn data:", JSON.stringify(updates));
            try {
                // Utiliser une mise à jour atomique pour garantir la cohérence
                await update(matchRef, updates);
                console.log("Match updated successfully after turn processing.");
                // Le onValue listener va détecter ce changement et mettre à jour l'UI
                // et potentiellement déclencher le timer pour le prochain tour.
            } catch (error) {
                console.error("ERROR during Firebase update in processTurn:", error);
                // Si l'update échoue, vous voudrez peut-être gérer une erreur côté utilisateur
                showMessage("action-msg", "Erreur critique lors du traitement du tour. Veuillez recharger la page.");
            }
        }


        // --- GESTION DU TIMER ---
        function resetTimerAndStart(currentPlayerKey, opponentPlayerKey, initialCount = timerMax) {
            if (timerInterval) clearInterval(timerInterval); // Arrête le timer précédent
            timerCount = initialCount;
            updateTimerUI(timerCount);
            console.log(`Timer started for ${currentUser.pseudo} (${currentPlayerKey}) with initial count: ${initialCount}`);

            timerInterval = setInterval(async () => {
                timerCount--;
                updateTimerUI(timerCount);

                if (timerCount <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    disableActionButtons(true); 
                    console.log("Timer expired.");

                    // Vérifier si le joueur a réellement joué avant de forcer une action
                    const matchRef = ref(db, `matches/${currentMatchId}`);
                    const matchSnapshot = await get(matchRef);
                    const matchData = matchSnapshot.val();

                    if (matchData && matchData.turn === currentPlayerKey && !matchData.players[currentPlayerKey].action) {
                        // Le joueur n'a pas joué à temps, enregistrer une action par défaut
                        console.log(`${currentUser.pseudo} (${currentPlayerKey}) has timed out, default action: Defend.`);
                        const defaultAction = 'defend'; 
                        const updates = {};
                        updates[`players/${currentPlayerKey}/action`] = defaultAction;
                        
                        const newHistory = [...(matchData.history || [])];
                        newHistory.push(`${currentUser.pseudo} n'a pas agi à temps et s'est automatiquement défendu.`);
                        updates.history = newHistory;

                        try {
                            await update(matchRef, updates);
                            // hasPlayedThisTurn reste à true jusqu'au prochain tour pour éviter le double envoi
                            // mais le timer s'arrête.
                            actionMsgEl.textContent = "Temps écoulé ! Votre action a été automatiquement choisie (Défense).";
                            console.log("Default action (Defend) submitted due to timeout.");
                        } catch (error) {
                            console.error("Error updating match with timeout action:", error);
                            showMessage("action-msg", "Erreur lors de l'envoi de l'action par défaut.");
                        }
                    } else {
                        console.log("Timer expired but action already present or not player's turn anymore.");
                    }
                }
            }, 1000); // Mise à jour chaque seconde
        }

        // --- ACTIONS DU JOUEUR ---
        async function performAction(actionType) {
            // Vérifier d'abord si hasPlayedThisTurn est VRAI avant de faire le get.
            // Si c'est déjà true, c'est que le joueur a déjà soumis son action pour ce tour.
            if (hasPlayedThisTurn) {
                showMessage("action-msg", "Vous avez déjà soumis une action pour ce tour.");
                console.log("Action blocked: already played this turn (hasPlayedThisTurn is true).");
                return;
            }
            if (!currentMatchId || !currentUser) {
                console.log("Action blocked: No match or no user.");
                return;
            }
            console.log(`Attempting to perform action: ${actionType}`);

            const matchRef = ref(db, `matches/${currentMatchId}`);
            const matchSnapshot = await get(matchRef);
            const matchData = matchSnapshot.val();

            if (!matchData) {
                showMessage("action-msg", "Match introuvable ou terminé.");
                backToMenu(true);
                console.log("Match not found for action.");
                return;
            }

            let playerKeyInMatch;
            if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                playerKeyInMatch = "p1";
            } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                playerKeyInMatch = "p2";
            } else {
                showMessage("action-msg", "Erreur: Votre rôle dans le match est indéterminé.");
                console.error("Player key in match not found for current user.");
                return;
            }

            if (matchData.turn !== playerKeyInMatch) {
                showMessage("action-msg", "Ce n'est pas votre tour !");
                console.log("Not player's turn to act.");
                return;
            }

            // Vérifier si l'action a déjà été enregistrée dans Firebase pour ce tour
            // C'est une double-vérification avec hasPlayedThisTurn, mais importante pour la robustesse.
            if (matchData.players[playerKeyInMatch].action) {
                 showMessage("action-msg", "Vous avez déjà soumis une action pour ce tour (vérification Firebase).");
                 console.log("Action already submitted for this turn (Firebase check).");
                 hasPlayedThisTurn = true; // S'assurer que hasPlayedThisTurn est à true
                 disableActionButtons(true); // Et les boutons désactivés
                 return;
            }

            // Enregistrer l'action dans Firebase
            const updates = {};
            updates[`players/${playerKeyInMatch}/action`] = actionType; 

            const actionDisplayName = {
                'attack': 'Attaque',
                'defend': 'Défense',
                'heal': 'Soin'
            }[actionType];
            
            actionMsgEl.textContent = `Vous avez choisi : ${actionDisplayName}. En attente de l'adversaire...`;
            console.log(`Submitting action '${actionType}' for ${currentUser.pseudo} (${playerKeyInMatch}).`);

            try {
                await update(matchRef, updates);
                hasPlayedThisTurn = true; // Marquer comme joué pour ce tour sur le client
                disableActionButtons(true);
                if (timerInterval) clearInterval(timerInterval); // Arrêter le timer une fois l'action soumise
                timerInterval = null; 
                console.log(`Action '${actionType}' submitted by ${currentUser.pseudo}. Timer stopped.`);
            } catch (error) {
                console.error("Error performing action:", error);
                showMessage("action-msg", "Erreur lors de l'envoi de votre action.");
            }
        }

        attackBtn.onclick = () => performAction('attack');
        defendBtn.onclick = () => performAction('defend');
        healBtn.onclick = () => performAction('heal');


        // --- MISE À JOUR DES STATISTIQUES UTILISATEUR ---
        async function updateUserStats(result) {
            if (!currentUser || !currentUser.pseudo) return;

            const userStatsRef = ref(db, `users/${currentUser.pseudo}`);
            try {
                const snapshot = await get(userStatsRef);
                if (snapshot.exists()) {
                    let { wins, losses } = snapshot.val();
                    wins = wins || 0;
                    losses = losses || 0;

                    if (result === 'win') {
                        wins++;
                    } else if (result === 'loss') {
                        losses++;
                    }
                    // 'draw' n'affecte pas les wins/losses ici

                    await update(userStatsRef, { wins, losses });
                    console.log(`Stats for ${currentUser.pseudo} updated: Wins=${wins}, Losses=${losses}`);
                }
            } catch (error) {
                console.error("Error updating user stats:", error);
            }
        }

        // --- GESTION DE LA FIN DE PARTIE ---
        async function handleGameEnd(data, youKeyPlayed, opponentKeyPlayed, finalResult) {
            console.log(`handleGameEnd called. Final result: ${finalResult}`);
            disableActionButtons(true);
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (onDisconnectRef) {
                onDisconnectRef.cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                onDisconnectRef = null;
            }

            let finalMessage = "";
            let yourResultForStats = finalResult; // Default, will be updated for forfeit

            if (finalResult === 'win') {
                finalMessage = `Victoire ! Vous avez gagné le match contre ${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'l\'adversaire'} !`;
            } else if (finalResult === 'loss') {
                finalMessage = `Défaite... Vous avez perdu contre ${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'l\'adversaire'}.`;
            } else if (finalResult === 'draw') {
                finalMessage = "Match Nul ! Personne n'a gagné.";
            } else if (finalResult === 'forfeit_win') { // Forfeit win by opponent disconnect
                 finalMessage = `Victoire par forfait ! L'adversaire (${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'inconnu'}) s'est déconnecté.`;
                 yourResultForStats = 'win';
            } else if (finalResult === 'forfeit_loss') { // Forfeit loss by your own disconnect (less common but possible)
                 finalMessage = "Vous avez perdu par forfait (déconnexion).";
                 yourResultForStats = 'loss';
            }
            else { 
                finalMessage = "Le match est terminé.";
            }

            actionMsgEl.textContent = finalMessage;
            updateUserStats(yourResultForStats); // Mettre à jour les stats

            if (!matchDeletionTimeout) { 
                actionMsgEl.textContent += " Retour au menu dans 10 secondes...";
                matchDeletionTimeout = setTimeout(async () => {
                    console.log(`Match ${currentMatchId} ended, attempting cleanup.`);
                    // Seul P1 (le créateur) ou un client avec la certitude que l'adversaire est parti
                    // devrait tenter de supprimer le match. Pour un duel, P1 est un bon candidat.
                    // Si le match est à 'forfeited' et que youKey est le gagnant par forfait, il peut aussi nettoyer.
                    const matchRef = ref(db, `matches/${currentMatchId}`);
                    const snapshot = await get(matchRef);
                    const currentData = snapshot.val();

                    if (currentData && (currentData.status === 'finished' || currentData.status === 'forfeited')) {
                         // Only the winner (if applicable) or P1 tries to delete.
                         // Or if the match is already forfeited and it was this client who caused it (via onDisconnect).
                         const shouldDelete = (youKeyPlayed === 'p1') || 
                                              (currentData.status === 'forfeited' && currentData.winner === youKeyPlayed);

                         if (shouldDelete) {
                             try {
                                 await remove(matchRef);
                                 console.log(`Match ${currentMatchId} removed.`);
                             } catch (err) {
                                 console.error("Error removing finished match:", err);
                             }
                         } else {
                             console.log(`Client ${youKeyPlayed} (not P1 or not winner of forfeit) skipping match deletion.`);
                         }
                    } else {
                        console.log("Match already deleted or status changed before deletion attempt.");
                    }
                    backToMenu(true); 
                    matchDeletionTimeout = null;
                }, 10000); 
            }
        }


        // --- RETOUR AU MENU ---
        function backToMenu(force = false) {
            console.log(`Returning to menu (force: ${force}). Current Match ID: ${currentMatchId}`);
            // Nettoyage complet
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
                console.log("Match listener unsubscribed.");
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                console.log("Timer interval cleared.");
            }
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
                console.log("Match deletion timeout cleared.");
            }
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
                console.log("Match creation listener unsubscribed.");
            }
            if (onDisconnectRef) { // Annuler onDisconnect si défini
                onDisconnectRef.cancel().then(() => {
                    console.log("onDisconnect operation cancelled.");
                }).catch(err => {
                    console.error("Error canceling onDisconnect on backToMenu:", err);
                });
                onDisconnectRef = null;
            }

            // Gérer le forfait si le joueur quitte un match en cours volontairement
            if (currentMatchId && currentUser && !force) {
                const matchRef = ref(db, `matches/${currentMatchId}`);
                console.log(`Attempting to forfeit match ${currentMatchId} for ${currentUser.pseudo}.`);
                get(matchRef).then(snapshot => {
                    const matchData = snapshot.val();
                    // Vérifier si le match est toujours "playing" et que le joueur y est
                    if (matchData && matchData.status === 'playing') {
                        let quitterKey = null;
                        let opponentKeyForForfeit = null;

                        if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                            quitterKey = "p1"; opponentKeyForForfeit = "p2";
                        } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                            quitterKey = "p2"; opponentKeyForForfeit = "p1";
                        }

                        // S'assurer que le joueur est bien dans le match et qu'il y a un adversaire actif
                        if (quitterKey && matchData.players[opponentKeyForForfeit] && matchData.players[opponentKeyForForfeit].status === 'connected') { 
                            const updates = {};
                            updates[`players/${quitterKey}/pv`] = 0; 
                            updates[`players/${quitterKey}/status`] = 'forfeited';
                            updates.status = 'forfeited';
                            updates.winner = opponentKeyForForfeit; 
                            updates.history = [...(matchData.history || [])]; // Copie l'historique existant
                            updates.history.push(`${currentUser.pseudo} a quitté le match. ${matchData.players[opponentKeyForForfeit].pseudo} gagne par forfait.`);
                            
                            update(matchRef, updates)
                                .then(() => console.log(`${currentUser.pseudo} left and forfeited match ${currentMatchId}`))
                                .catch(err => console.error("Error updating match on forfeit:", err));
                        } else {
                            console.log("Not in a playing match or opponent not connected for forfeit logic.");
                        }
                    } else {
                        console.log("Match not in 'playing' status or data missing for voluntary forfeit.");
                    }
                }).catch(err => console.error("Error getting match for backToMenu forfeit:", err));
            }

            currentMatchId = null;
            hasPlayedThisTurn = false;
            youKey = null; // Réinitialiser
            opponentKey = null; // Réinitialiser

            showMessage("action-msg", ""); 
            showMessage("match-msg", ""); 
            if (opponentActionStatusEl) opponentActionStatusEl.textContent = "";

            document.getElementById("game").style.display = "none";
            document.getElementById("match").style.display = "block";
            
            matchIdInput.value = "";
        }

        backToMenuBtn.onclick = () => backToMenu(); 

        // Initialiser l'affichage
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById("auth").style.display = "block";
        });
    </script>
</body>
</html>