<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Duel 1v1 Multijoueur</title>
    <style>
        :root {
            --main-color: #00ffd5;
            --bg-color: #0e0e0e;
            --text-color: #e0e0e0;
            --input-bg: #1a1a1a;
            --button-bg: linear-gradient(135deg, #00ffd5, #00b3ff);
            --danger: #ff4d6d;
            --warning: #ff7700;
            --critical: #ff0000;
            --heal: #00ff88;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            text-align: center;
        }

        h1, h2, h3 {
            color: var(--main-color);
            margin-bottom: 15px;
        }

        input {
            padding: 12px;
            margin: 10px 5px;
            border-radius: 8px;
            border: 1px solid #222;
            background-color: var(--input-bg);
            color: #eee;
            font-size: 1rem;
            width: 200px;
            max-width: 80vw;
            outline: none;
            transition: 0.3s;
        }

        input:focus {
            box-shadow: 0 0 6px 2px var(--main-color);
            background-color: #222;
        }

        button {
            background: var(--button-bg);
            border: none;
            border-radius: 8px;
            color: #0e0e0e;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 10px 8px;
            padding: 12px 30px;
            transition: 0.3s ease;
            min-width: 150px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 213, 0.4);
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
            color: #aaa;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 15px;
        }

        #actions {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        #actions button {
            flex-grow: 1;
            min-width: 120px;
        }

        #history {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background: #222;
            color: #eee;
            text-align: left;
            border-radius: 8px;
            margin-top: 15px;
        }

        #history p {
            margin: 6px 0;
            font-size: 0.95rem;
            color: #a0a0a0;
        }

        #auth-msg,
        #match-msg,
        #action-msg {
            color: var(--danger);
            font-weight: bold;
            margin-top: 12px;
            min-height: 26px;
        }

        #game p {
            font-size: 1.1rem;
            margin: 8px 0;
        }

        #you-name, #opponent-name {
            font-weight: 700;
            color: var(--main-color);
        }

        .player-info {
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #1c1c1c;
        }

        .health-bar-container {
            width: 100%;
            background-color: #555;
            border-radius: 5px;
            height: 20px;
            margin-top: 5px;
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            width: 100%;
            background-color: var(--heal);
            border-radius: 5px;
            transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
            text-align: center;
            color: black;
            font-weight: bold;
            line-height: 20px;
        }

        #you-health-bar.low,
        #opponent-health-bar.low {
            background-color: var(--warning);
        }

        #you-health-bar.critical,
        #opponent-health-bar.critical {
            background-color: var(--critical);
        }

        #opponent-health-bar {
            background-color: var(--danger);
        }

        #timer-display {
            font-weight: 700;
            font-size: 1.2rem;
            margin-top: 12px;
            color: #ffdd00;
        }

        #timer-progress-bar-container {
            width: 90%;
            max-width: 400px;
            height: 10px;
            background: #333;
            margin: 10px auto;
            border-radius: 5px;
            overflow: hidden;
        }

        #timer-progress-bar {
            height: 100%;
            width: 100%;
            background-color: var(--main-color);
            transition: width 1s linear;
            border-radius: 5px;
        }

        .damage-effect {
            animation: damagePulse 0.5s ease-out;
        }

        @keyframes damagePulse {
            0% { transform: scale(1); color: var(--danger); }
            50% { transform: scale(1.1); color: var(--critical); }
            100% { transform: scale(1); color: var(--danger); }
        }

        .heal-effect {
            animation: healPulse 1s ease-out;
        }

        @keyframes healPulse {
            0% { transform: scale(1); color: var(--heal); }
            50% { transform: scale(1.1); color: #88ffcc; }
            100% { transform: scale(1); color: var(--heal); }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.8rem;
            }

            input,
            button {
                width: calc(100% - 20px);
                margin: 10px auto;
                display: block;
            }

            #actions {
                flex-direction: column;
            }

            #actions button {
                width: 100%;
            }

            .container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>Duel 1v1 Multijoueur</h1>

    <div id="auth" class="container">
        <h2>Authentification</h2>
        <input id="pseudo" placeholder="Pseudo (min 2 caractères)" />
        <input id="code" type="password" placeholder="Code (4 chiffres)" maxlength="4" />
        <button id="signup-btn">S'inscrire</button>
        <button id="login-btn">Connexion</button>
        <p id="auth-msg"></p>
    </div>

    <div id="match" style="display:none;" class="container">
        <h2>Matchmaking</h2>
        <p>Connecté en tant que <strong id="player-name"></strong></p>
        <input id="match-id" placeholder="Code du match (ex: duel123)" />
        <button id="create-match-btn">Créer un match</button>
        <button id="join-match-btn">Rejoindre un match</button>
        <p id="match-msg"></p>
    </div>

    <div id="game" style="display:none;" class="container">
        <h2>Match: <span id="current-match"></span></h2>
        
        <div class="player-info">
            <p><strong id="you-name"></strong> (PV: <span id="you-pv-display">100</span>)</p>
            <div class="health-bar-container">
                <div id="you-health-bar" class="health-bar">100%</div>
            </div>
        </div>

        <div class="player-info">
            <p><strong id="opponent-name">Adversaire</strong> (PV: <span id="opponent-pv-display">100</span>)</p>
            <div class="health-bar-container">
                <div id="opponent-health-bar" class="health-bar">100%</div>
            </div>
        </div>

        <p id="timer-display">Temps restant : <span id="timer-value">30</span>s</p> <div id="timer-progress-bar-container"> <div id="timer-progress-bar"></div> </div>
        
        <p id="action-msg"></p>

        <div id="actions">
            <button id="attack-btn">🗡️ Attaquer</button>
            <button id="defend-btn">🛡️ Défendre</button>
            <button id="heal-btn">🧪 Se soigner</button>
        </div>

        <h3>Historique</h3>
        <div id="history"></div>

        <button id="back-to-menu-btn" style="margin-top: 20px; background: #555;">Quitter le Match</button>
    </div>

    <script type="module">
        // Import Firebase (corrected paths)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, update, push, child, remove, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";
        
        // --- CONFIGURATION FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyA-e19z8T3c1K46YmJY8s9EAbO9BRes7fA", // REMPLACEZ PAR VOTRE VRAIE CLÉ API
            authDomain: "mini-duel-de-cartes.firebaseapp.com",
            databaseURL: "https://mini-duel-de-cartes-default-rtdb.firebaseio.com",
            projectId: "mini-duel-de-cartes",
            storageBucket: "mini-duel-de-cartes.appspot.com", 
            messagingSenderId: "1084207708579",
            appId: "1:1084207708579:web:f1312b68b7eb08f9d44216",
            measurementId: "G-7YW3J41XZF" 
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- VARIABLES GLOBALES ---
        let currentUser = null; // { pseudo, code }
        let currentMatchId = null; 
        let hasPlayedThisTurn = false; // Vrai si le joueur a soumis son action pour le tour actuel
        let timerInterval = null;
        const timerMax = 20; // secondes (réduit le temps pour un jeu plus rapide)
        let timerCount = timerMax;
        let youKey = null; // 'p1' or 'p2' for the current user in the match
        let opponentKey = null; // 'p1' or 'p2' for the opponent

        let unsubscribeMatchCreationListener = null; 
        let matchDeletionTimeout = null; 
        let currentMatchUnsubscribe = null; 
        let onDisconnectRef = null; // To store the onDisconnect reference for proper cancellation

        // --- DOM Elements Cache ---
        const pseudoInput = document.getElementById("pseudo");
        const codeInput = document.getElementById("code");
        const authMsgEl = document.getElementById("auth-msg");
        const matchIdInput = document.getElementById("match-id");
        const matchMsgEl = document.getElementById("match-msg");
        const actionMsgEl = document.getElementById("action-msg");
        const youPvDisplayEl = document.getElementById("you-pv-display");
        const opponentPvDisplayEl = document.getElementById("opponent-pv-display");
        const youHealthBarEl = document.getElementById("you-health-bar");
        const opponentHealthBarEl = document.getElementById("opponent-health-bar");
        const timerValueEl = document.getElementById("timer-value");
        const timerProgressBarEl = document.getElementById("timer-progress-bar");
        const attackBtn = document.getElementById("attack-btn");
        const defendBtn = document.getElementById("defend-btn");
        const healBtn = document.getElementById("heal-btn");
        const backToMenuBtn = document.getElementById("back-to-menu-btn");


        // --- FONCTIONS UTILITAIRES ---

        function showMessage(elementId, message, isSuccess = false) {
            const el = document.getElementById(elementId);
            if (el) {
                el.style.color = isSuccess ? "#00ff88" : "#ff4d6d";
                el.textContent = message;
                // Efface le message après un court délai s'il s'agit d'un message temporaire
                if (!isSuccess) {
                    setTimeout(() => {
                        if (el.textContent === message) el.textContent = "";
                    }, 5000); 
                }
            }
        }

        function disableActionButtons(disabled) {
            attackBtn.disabled = disabled;
            defendBtn.disabled = disabled;
            healBtn.disabled = disabled;
        }
        
        function updateHealthBar(healthBarElement, pvDisplayElement, currentPV, isOpponent = false) {
            const percentage = Math.max(0, Math.min(100, currentPV));
            healthBarElement.style.width = `${percentage}%`;
            healthBarElement.textContent = `${Math.round(percentage)}%`; // Arrondi le pourcentage

            // Ajout d'une animation si les PV ont changé (visuel)
            const oldPV = parseInt(pvDisplayElement.textContent);
            if (currentPV < oldPV) { // Dégâts
                healthBarElement.classList.add('damage-effect');
                setTimeout(() => healthBarElement.classList.remove('damage-effect'), 500);
            } else if (currentPV > oldPV) { // Soin
                healthBarElement.classList.add('heal-effect');
                setTimeout(() => healthBarElement.classList.remove('heal-effect'), 1000);
            }

            pvDisplayElement.textContent = currentPV;

            healthBarElement.classList.remove('low', 'critical');
            // Gérer les couleurs pour sa propre barre de vie et celle de l'adversaire
            if (isOpponent) {
                healthBarElement.style.backgroundColor = `var(--danger)`; // Rouge pour l'adversaire
            } else if (currentPV < 10) {
                healthBarElement.classList.add('critical');
            } else if (currentPV < 30) {
                healthBarElement.classList.add('low');
            } else {
                healthBarElement.style.backgroundColor = `var(--heal)`; // Vert par défaut
            }
        }

        function updateTimerUI(value) {
            timerValueEl.textContent = value;
            const progress = (value / timerMax) * 100;
            timerProgressBarEl.style.width = `${progress}%`;
            // Interpolation de couleur du vert au rouge
            const r = Math.min(255, Math.floor((100 - progress) * 2.55 * 2)); 
            const g = Math.min(255, Math.floor(progress * 2.55 * 2)); 
            timerProgressBarEl.style.backgroundColor = `rgb(${r}, ${g}, 0)`; 
        }


        // --- AUTHENTIFICATION ---

        document.getElementById("signup-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (pseudo.length < 2) {
                showMessage("auth-msg", "Pseudo trop court (min 2 caractères).");
                return;
            }
            if (!/^\d{4}$/.test(code)) {
                showMessage("auth-msg", "Code doit être composé de 4 chiffres.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("auth-msg", "Ce pseudo est déjà pris.");
                } else {
                    set(userRef, { code, wins: 0, losses: 0, createdAt: serverTimestamp() })
                        .then(() => {
                            showMessage("auth-msg", "Inscription réussie !", true);
                            currentUser = { pseudo, code };
                            afterLogin();
                        })
                        .catch(error => {
                            console.error("Signup error:", error);
                            showMessage("auth-msg", "Erreur lors de l'inscription.");
                        });
                }
            }).catch(error => {
                console.error("Checking user for signup error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("login-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (!pseudo || !code) {
                showMessage("auth-msg", "Pseudo et code requis.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("auth-msg", "Pseudo inconnu.");
                } else {
                    const data = snapshot.val();
                    if (data.code === code) {
                        showMessage("auth-msg", "Connexion réussie !", true);
                        currentUser = { pseudo, code };
                        afterLogin();
                    } else {
                        showMessage("auth-msg", "Code incorrect.");
                    }
                }
            }).catch(error => {
                console.error("Login error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        function afterLogin() {
            document.getElementById("auth").style.display = "none";
            document.getElementById("match").style.display = "block";
            document.getElementById("player-name").textContent = currentUser.pseudo;
            showMessage("auth-msg", ""); // Clear auth message
            pseudoInput.value = ""; // Clear inputs
            codeInput.value = "";
        }

        // --- MATCH ---

        document.getElementById("create-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code pour le match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("match-msg", "Ce code de match est déjà utilisé.");
                } else {
                    const initialMatchData = {
                        players: {
                            p1: { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null },
                            p2: null
                        },
                        turn: "p1", // Initial turn
                        history: [`Match ${matchId} créé par ${currentUser.pseudo}. En attente d'un adversaire...`],
                        status: "waiting", // waiting, playing, finished, forfeited
                        createdAt: serverTimestamp(),
                        lastTurnProcessedAt: serverTimestamp() // Timestamp to help sync timer across clients
                    };
                    set(matchRef, initialMatchData).then(() => {
                        showMessage("match-msg", "Match créé. En attente de l'adversaire...", true);
                        startMatchMonitoring(matchId); 

                        // Cleanup listener for unjoined match - improved
                        if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); // Clear previous
                        unsubscribeMatchCreationListener = onValue(matchRef, (matchSnapshot) => {
                            const matchData = matchSnapshot.val();
                            if (!matchData) { // Match was deleted
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                                return;
                            }
                            if (matchData.status === 'waiting' && !matchData.players.p2 && matchData.createdAt) {
                                const timeElapsed = Date.now() - matchData.createdAt;
                                if (timeElapsed > 60000) { // 1 minute timeout for waiting match
                                    console.log(`Match ${matchId} non rejoint après 1 minute, suppression.`);
                                    remove(matchRef)
                                        .then(() => {
                                            showMessage("match-msg", "Match expiré et supprimé (aucun adversaire).");
                                            if (currentMatchId === matchId) { 
                                                backToMenu(true); 
                                            }
                                        })
                                        .catch(err => console.error("Error removing expired match:", err));
                                    if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); 
                                    unsubscribeMatchCreationListener = null;
                                }
                            } else if (matchData.players.p2 && matchData.status === 'playing') { // Opponent joined
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                            }
                        });

                    }).catch(error => {
                        console.error("Error creating match:", error);
                        showMessage("match-msg", "Erreur lors de la création du match.");
                    });
                }
            }).catch(error => {
                console.error("Error checking match existence:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("join-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code de match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("match-msg", "Ce match n'existe pas.");
                    return;
                }

                const matchData = snapshot.val();
                if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                    showMessage("match-msg", "Vous êtes déjà le créateur de ce match. Attendez un joueur.");
                    startMatchMonitoring(matchId); 
                    return;
                }
                if (matchData.players.p2) {
                    showMessage("match-msg", "Ce match est déjà complet.");
                    return;
                }
                if (matchData.status !== 'waiting') {
                    showMessage("match-msg", "Ce match n'est plus en attente de joueurs.");
                    return;
                }
                
                const updates = {};
                updates[`players/p2`] = { pseudo: currentUser.pseudo, pv: 100, status: 'connected', lastSeen: serverTimestamp(), action: null };
                updates[`status`] = 'playing';
                updates[`history`] = [...(matchData.history || []), `${currentUser.pseudo} a rejoint le match ! Le duel commence.`];
                updates[`lastTurnProcessedAt`] = serverTimestamp(); // Sync timer on join

                update(matchRef, updates).then(() => {
                    showMessage("match-msg", "Vous avez rejoint le match !", true);
                    startMatchMonitoring(matchId);
                }).catch(error => {
                    console.error("Error joining match:", error);
                    showMessage("match-msg", "Erreur pour rejoindre le match.");
                });
            }).catch(error => {
                console.error("Error getting match to join:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };
        
        // --- DÉBUT ET SUIVI DU MATCH ---
        function startMatchMonitoring(id) {
            // Nettoyage des listeners précédents
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe(); 
                currentMatchUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (onDisconnectRef) {
                onDisconnectRef.cancel().catch(err => console.error("Error canceling old onDisconnect:", err));
                onDisconnectRef = null;
            }
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
            }
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
            }

            currentMatchId = id;
            const matchRef = ref(db, `matches/${id}`);

            document.getElementById("match").style.display = "none";
            document.getElementById("game").style.display = "block";
            document.getElementById("current-match").textContent = id;
            document.getElementById("you-name").textContent = currentUser.pseudo;
            document.getElementById("history").innerHTML = ""; // Clear history on new match start

            hasPlayedThisTurn = false;
            disableActionButtons(true); // Initialisation: boutons désactivés
            actionMsgEl.textContent = "Chargement du match...";

            currentMatchUnsubscribe = onValue(matchRef, async (snapshot) => {
                console.log("onValue triggered:", snapshot.val()); // Pour le débogage
                const data = snapshot.val();
                if (!data) {
                    // Match supprimé ou inexistant
                    if (currentMatchId === id) { 
                        showMessage("action-msg", "Le match a été terminé ou supprimé.");
                        if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                        currentMatchUnsubscribe = null;
                        setTimeout(() => backToMenu(true), 3000);
                    }
                    return;
                }

                // Déterminer le rôle du joueur actuel (p1 ou p2)
                let you, opponent;
                if (data.players.p1 && data.players.p1.pseudo === currentUser.pseudo) {
                    you = data.players.p1; youKey = "p1";
                    opponent = data.players.p2; opponentKey = "p2";
                } else if (data.players.p2 && data.players.p2.pseudo === currentUser.pseudo) {
                    you = data.players.p2; youKey = "p2";
                    opponent = data.players.p1; opponentKey = "p1";
                } else {
                    // N'est pas un joueur dans ce match (ex: a été déconnecté/kické)
                    actionMsgEl.textContent = "Vous n'êtes pas un joueur dans ce match.";
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    return;
                }
                
                // Mettre à jour lastSeen et définir onDisconnect
                const yourPlayerRef = ref(db, `matches/${id}/players/${youKey}`);
                if (!onDisconnectRef) { // Set onDisconnect only once per match
                    onDisconnectRef = onDisconnect(yourPlayerRef);
                    onDisconnectRef.update({
                        pv: 0, 
                        status: 'disconnected',
                        lastSeen: serverTimestamp() 
                    }).catch(error => console.error("Error setting onDisconnect:", error));
                }
                // Mise à jour régulière de lastSeen pour signaler la présence
                update(yourPlayerRef, { lastSeen: serverTimestamp(), status: 'connected' }); 

                // Mettre à jour l'interface avec les données des joueurs
                updateHealthBar(youHealthBarEl, youPvDisplayEl, you.pv);
                document.getElementById("you-name").textContent = `${you.pseudo} (Vous)`;

                if (opponent) {
                    updateHealthBar(opponentHealthBarEl, opponentPvDisplayEl, opponent.pv, true); // true pour l'adversaire
                    document.getElementById("opponent-name").textContent = opponent.pseudo;
                } else {
                    opponentPvDisplayEl.textContent = "N/A";
                    opponentHealthBarEl.style.width = "0%";
                    opponentHealthBarEl.textContent = "0%";
                    document.getElementById("opponent-name").textContent = "En attente...";
                }
                
                // Si en attente du P2 ou si P2 est déconnecté/forfait
                if (data.status === "waiting" || !opponent || opponent.status === 'disconnected' || opponent.status === 'forfeited') {
                    if (opponent && (opponent.status === 'disconnected' || opponent.status === 'forfeited')) {
                        actionMsgEl.textContent = `L'adversaire (${opponent.pseudo}) est déconnecté. Le match est terminé.`;
                        handleGameEnd(data, youKey, opponentKey, 'win'); // You win by forfeit
                    } else {
                        actionMsgEl.textContent = "En attente de l'adversaire...";
                    }
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    updateTimerUI(timerMax); // Reset timer display
                    return;
                }
                
                // Conditions de fin de jeu (après avoir géré l'attente)
                if (data.status === 'finished' || you.pv <= 0 || opponent.pv <= 0) {
                    // Unsubscribe onDisconnect as match is ending
                    if (onDisconnectRef) {
                        onDisconnectRef.cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                        onDisconnectRef = null;
                    }

                    let finalResult = "draw";
                    if (you.pv > 0 && opponent.pv <= 0) {
                        finalResult = "win";
                    } else if (you.pv <= 0 && opponent.pv > 0) {
                        finalResult = "loss";
                    }
                    handleGameEnd(data, youKey, opponentKey, finalResult);
                    return; 
                }

                // Gérer les actions si c'est le tour actuel et que les deux actions sont là
                // SEULEMENT le joueur P1 (le créateur du match) est désigné pour traiter les actions
                // pour éviter les courses et les boucles de mise à jour.
                if (data.players.p1.action && data.players.p2.action) {
                    if (youKey === 'p1') { // Seul P1 traite le tour
                        console.log("P1 détecte les deux actions, va traiter le tour.");
                        // Ajoutez une petite temporisation pour s'assurer que les données sont bien propagées
                        // avant que P1 ne tente de lire et de traiter.
                        // Cela peut aussi aider à éviter la saturation de la pile d'appels.
                        setTimeout(() => {
                            // Re-vérifiez l'état juste avant de traiter pour éviter les doublons
                            get(matchRef).then(latestSnapshot => {
                                const latestData = latestSnapshot.val();
                                if (latestData && latestData.players.p1.action && latestData.players.p2.action) {
                                    processTurn(latestData, youKey, opponentKey, matchRef);
                                } else {
                                    console.log("Actions déjà traitées ou non présentes au moment du traitement par P1.");
                                }
                            }).catch(err => console.error("Error getting latest match data for processing:", err));
                        }, 50); // Petite pause de 50ms
                    } else {
                        console.log("P2 détecte les deux actions, P1 est responsable du traitement.");
                        // P2 va simplement attendre que P1 mette à jour le match
                    }
                    hasPlayedThisTurn = false; // Réinitialiser pour le prochain tour après traitement
                    return; // Sortir pour ne pas refaire la logique de tour
                }


                // Gestion du Tour
                if (data.turn === youKey) {
                    if (hasPlayedThisTurn) { // Si le joueur a déjà cliqué pour ce tour
                        disableActionButtons(true);
                        actionMsgEl.textContent = "Action jouée. En attente de l'adversaire...";
                        if (timerInterval) clearInterval(timerInterval); 
                        timerInterval = null;
                    } else { // C'est votre tour et vous n'avez pas encore joué
                        disableActionButtons(false);
                        actionMsgEl.textContent = "C'est votre tour ! Choisissez une action.";
                        if (!timerInterval) { 
                             // Synchroniser le timer avec la base de données
                            const elapsedSinceLastTurn = data.lastTurnProcessedAt ? (Date.now() - data.lastTurnProcessedAt) : 0;
                            const initialTimerValue = Math.max(0, timerMax - Math.floor(elapsedSinceLastTurn / 1000));
                            resetTimerAndStart(youKey, opponentKey, initialTimerValue);
                        }
                    }
                } else { // Tour de l'adversaire
                    disableActionButtons(true);
                    actionMsgEl.textContent = `Tour de ${opponent ? opponent.pseudo : 'l\'adversaire'}. Veuillez patienter...`;
                    if (timerInterval) clearInterval(timerInterval); 
                    timerInterval = null;
                    hasPlayedThisTurn = false; // Important: Réinitialiser pour votre prochain tour
                    updateTimerUI(timerMax); // Afficher le timer plein pour l'adversaire (visuellement)
                }

                // Mettre à jour l'historique
                const histEl = document.getElementById("history");
                histEl.innerHTML = ""; 
                (data.history || []).forEach(entry => {
                    const p = document.createElement("p");
                    p.textContent = entry;
                    histEl.appendChild(p);
                });
                histEl.scrollTop = histEl.scrollHeight; 

            }, (error) => {
                console.error("Error listening to match data:", error);
                showMessage("action-msg", "Erreur de connexion au match. Retour au menu.");
                if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
                setTimeout(() => backToMenu(true), 3000);
            });
        }

        // --- RESOLUTION DU TOUR (Nouvelle Fonction) ---
        async function processTurn(data, youKeyCurrentListener, opponentKeyCurrentListener, matchRef) {
            console.log("Processing turn (by P1 if logic is followed)...");
            // Vérifiez encore une fois que les actions sont non-nulles pour éviter le double traitement
            if (!data.players.p1.action || !data.players.p2.action) {
                console.log("One or both actions are null, turn already processed or not ready.");
                return; // Ne rien faire si les actions sont déjà effacées
            }

            if (timerInterval) {
                clearInterval(timerInterval); // Stop timer immediately when processing
                timerInterval = null;
            }
            disableActionButtons(true); // Disable buttons during processing

            const p1Action = data.players.p1.action;
            const p2Action = data.players.p2.action;

            let p1PV = data.players.p1.pv;
            let p2PV = data.players.p2.pv;
            let historyUpdates = [...(data.history || [])];

            historyUpdates.push(`--- Début du tour ${data.turn} ---`);
            
            // Logique d'application des actions
            // Attaque
            if (p1Action === 'attack') {
                historyUpdates.push(`${data.players.p1.pseudo} attaque !`);
                if (p2Action === 'defend') {
                    p2PV -= 5; 
                    historyUpdates.push(`${data.players.p2.pseudo} se défend, subit 5 PV de dégâts.`);
                } else {
                    p2PV -= 10; 
                    historyUpdates.push(`${data.players.p2.pseudo} subit 10 PV de dégâts.`);
                }
            }
            if (p2Action === 'attack') {
                historyUpdates.push(`${data.players.p2.pseudo} attaque !`);
                if (p1Action === 'defend') {
                    p1PV -= 5; 
                    historyUpdates.push(`${data.players.p1.pseudo} se défend, subit 5 PV de dégâts.`);
                } else {
                    p1PV -= 10; 
                    historyUpdates.push(`${data.players.p1.pseudo} subit 10 PV de dégâts.`);
                }
            }

            // Soin
            if (p1Action === 'heal') {
                p1PV = Math.min(100, p1PV + 15);
                historyUpdates.push(`${data.players.p1.pseudo} se soigne et récupère 15 PV.`);
            }
            if (p2Action === 'heal') {
                p2PV = Math.min(100, p2PV + 15);
                historyUpdates.push(`${data.players.p2.pseudo} se soigne et récupère 15 PV.`);
            }

            // Défense (déjà géré dans l'attaque, mais on peut loguer pour la clarté)
            if (p1Action === 'defend' && p2Action !== 'attack') {
                historyUpdates.push(`${data.players.p1.pseudo} se met en position défensive.`);
            }
            if (p2Action === 'defend' && p1Action !== 'attack') {
                historyUpdates.push(`${data.players.p2.pseudo} se met en position défensive.`);
            }

            historyUpdates.push(`--- Fin du tour ---`);

            // S'assurer que les PV ne sont pas négatifs
            p1PV = Math.max(0, p1PV);
            p2PV = Math.max(0, p2PV);

            // Déterminer le prochain tour ou la fin du match
            let nextTurn = (data.turn === 'p1') ? 'p2' : 'p1';
            let gameStatus = 'playing';
            let winner = null;
            let loser = null;

            if (p1PV <= 0 && p2PV <= 0) {
                gameStatus = "finished";
                winner = "draw";
                historyUpdates.push("Les deux joueurs sont à terre. C'est un match nul !");
            } else if (p1PV <= 0) {
                gameStatus = "finished";
                winner = "p2";
                loser = "p1";
                historyUpdates.push(`${data.players.p1.pseudo} est vaincu ! ${data.players.p2.pseudo} gagne le match.`);
            } else if (p2PV <= 0) {
                gameStatus = "finished";
                winner = "p1";
                loser = "p2";
                historyUpdates.push(`${data.players.p2.pseudo} est vaincu ! ${data.players.p1.pseudo} gagne le match.`);
            }

            const updates = {
                [`players/p1/pv`]: p1PV,
                [`players/p2/pv`]: p2PV,
                [`players/p1/action`]: null, // Réinitialise l'action du joueur 1 pour le prochain tour
                [`players/p2/action`]: null, // Réinitialise l'action du joueur 2 pour le prochain tour
                history: historyUpdates,
                turn: nextTurn,
                status: gameStatus,
                lastTurnProcessedAt: serverTimestamp() // Mettre à jour le timestamp pour le timer
            };

            if (winner) {
                updates.winner = winner;
                if (loser) updates.loser = loser;
            }

            try {
                // Utiliser une mise à jour atomique pour garantir la cohérence
                await update(matchRef, updates);
                console.log("Match updated after turn processing.");
                // Le onValue listener va détecter ce changement et mettre à jour l'UI
                // et potentiellement déclencher le timer pour le prochain tour.
            } catch (error) {
                console.error("Error updating match after processing turn:", error);
            }
        }


        // --- GESTION DU TIMER ---
        function resetTimerAndStart(currentPlayerKey, opponentPlayerKey, initialCount = timerMax) {
            if (timerInterval) clearInterval(timerInterval); // Arrête le timer précédent
            timerCount = initialCount;
            updateTimerUI(timerCount);

            timerInterval = setInterval(async () => {
                timerCount--;
                updateTimerUI(timerCount);

                if (timerCount <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    disableActionButtons(true); 

                    // Vérifier si le joueur a réellement joué avant de forcer une action
                    const matchRef = ref(db, `matches/${currentMatchId}`);
                    const matchSnapshot = await get(matchRef);
                    const matchData = matchSnapshot.val();

                    if (matchData && matchData.turn === currentPlayerKey && !matchData.players[currentPlayerKey].action) {
                        // Le joueur n'a pas joué à temps, enregistrer une action par défaut
                        console.log(`${currentUser.pseudo} a expiré son tour, action par défaut: Défense.`);
                        const defaultAction = 'defend'; 
                        const updates = {};
                        updates[`players/${currentPlayerKey}/action`] = defaultAction;
                        
                        const newHistory = [...(matchData.history || [])];
                        newHistory.push(`${currentUser.pseudo} n'a pas agi à temps et s'est automatiquement défendu.`);
                        updates.history = newHistory;

                        try {
                            await update(matchRef, updates);
                            hasPlayedThisTurn = true; // Marquer comme joué
                            actionMsgEl.textContent = "Temps écoulé ! Votre action a été automatiquement choisie (Défense).";
                        } catch (error) {
                            console.error("Error updating match with timeout action:", error);
                        }
                    }
                }
            }, 1000); // Mise à jour chaque seconde
        }

        // --- ACTIONS DU JOUEUR ---
        async function performAction(actionType) {
            if (!currentMatchId || !currentUser || hasPlayedThisTurn) {
                // message déjà affiché ou action déjà jouée
                return;
            }
            console.log(`Performing action: ${actionType}`);

            const matchRef = ref(db, `matches/${currentMatchId}`);
            // Pas besoin de get() ici si le onValue est rapide et que l'on vérifie l'état local du `data`
            // Mais pour la robustesse et éviter les conditions de course, on peut faire un get ponctuel.
            const matchSnapshot = await get(matchRef);
            const matchData = matchSnapshot.val();

            if (!matchData) {
                showMessage("action-msg", "Match introuvable ou terminé.");
                backToMenu(true);
                return;
            }

            // Vérifier le rôle du joueur actuel dans le match
            let playerKeyInMatch;
            if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                playerKeyInMatch = "p1";
            } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                playerKeyInMatch = "p2";
            } else {
                showMessage("action-msg", "Erreur: Votre rôle dans le match est indéterminé.");
                return;
            }

            if (matchData.turn !== playerKeyInMatch) {
                showMessage("action-msg", "Ce n'est pas votre tour !");
                return;
            }

            // Vérifier si l'action a déjà été enregistrée pour ce tour (prévention de double-clic)
            if (matchData.players[playerKeyInMatch].action) {
                 showMessage("action-msg", "Vous avez déjà soumis une action pour ce tour.");
                 return;
            }

            // Enregistrer l'action dans Firebase
            const updates = {};
            updates[`players/${playerKeyInMatch}/action`] = actionType; // Modifier pour stocker l'action directement sous le joueur

            const actionDisplayName = {
                'attack': 'Attaque',
                'defend': 'Défense',
                'heal': 'Soin'
            }[actionType];
            
            actionMsgEl.textContent = `Vous avez choisi : ${actionDisplayName}. En attente de l'adversaire...`;


            try {
                await update(matchRef, updates);
                hasPlayedThisTurn = true; // Marquer comme joué pour ce tour
                disableActionButtons(true);
                if (timerInterval) clearInterval(timerInterval); // Arrêter le timer une fois l'action soumise
                timerInterval = null; 
                console.log(`Action '${actionType}' submitted by ${currentUser.pseudo}.`);
            } catch (error) {
                console.error("Error performing action:", error);
                showMessage("action-msg", "Erreur lors de l'envoi de votre action.");
            }
        }

        attackBtn.onclick = () => performAction('attack');
        defendBtn.onclick = () => performAction('defend');
        healBtn.onclick = () => performAction('heal');


        // --- MISE À JOUR DES STATISTIQUES UTILISATEUR ---
        async function updateUserStats(result) {
            if (!currentUser || !currentUser.pseudo) return;

            const userStatsRef = ref(db, `users/${currentUser.pseudo}`);
            try {
                const snapshot = await get(userStatsRef);
                if (snapshot.exists()) {
                    let { wins, losses } = snapshot.val();
                    wins = wins || 0;
                    losses = losses || 0;

                    if (result === 'win') {
                        wins++;
                    } else if (result === 'loss') {
                        losses++;
                    }
                    // 'draw' n'affecte pas les wins/losses ici

                    await update(userStatsRef, { wins, losses });
                    console.log(`Stats for ${currentUser.pseudo} updated: Wins=${wins}, Losses=${losses}`);
                }
            } catch (error) {
                console.error("Error updating user stats:", error);
            }
        }

        // --- GESTION DE LA FIN DE PARTIE (Nouvelle fonction) ---
        async function handleGameEnd(data, youKeyPlayed, opponentKeyPlayed, finalResult) {
            disableActionButtons(true);
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (onDisconnectRef) {
                onDisconnectRef.cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                onDisconnectRef = null;
            }

            let finalMessage = "";
            let yourResultForStats = finalResult;

            if (finalResult === 'win') {
                finalMessage = `Victoire ! Vous avez gagné le match contre ${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'l\'adversaire'} !`;
            } else if (finalResult === 'loss') {
                finalMessage = `Défaite... Vous avez perdu contre ${data.players[opponentKeyPlayed] ? data.players[opponentKeyPlayed].pseudo : 'l\'adversaire'}.`;
            } else if (finalResult === 'draw') {
                finalMessage = "Match Nul ! Personne n'a gagné.";
            } else { 
                finalMessage = "Le match est terminé.";
            }

            actionMsgEl.textContent = finalMessage;
            updateUserStats(yourResultForStats); // Mettre à jour les stats

            if (!matchDeletionTimeout) { 
                actionMsgEl.textContent += " Retour au menu dans 10 secondes...";
                matchDeletionTimeout = setTimeout(async () => {
                    console.log(`Match ${currentMatchId} terminé, tentative de suppression.`);
                    // Seul P1 (le créateur) ou un client avec la certitude que l'adversaire est parti
                    // devrait tenter de supprimer le match. Pour un duel, P1 est un bon candidat.
                    if (youKeyPlayed === 'p1') {
                        try {
                            const matchRef = ref(db, `matches/${currentMatchId}`);
                            const snapshot = await get(matchRef);
                            // Vérifier si le match existe toujours et n'a pas été supprimé par l'autre client entre temps
                            if (snapshot.exists() && snapshot.val().status === 'finished') { 
                                 await remove(matchRef);
                                 console.log(`Match ${currentMatchId} supprimé.`);
                            }
                        } catch (err) {
                            console.error("Error removing finished match:", err);
                        }
                    }
                    backToMenu(true); 
                    matchDeletionTimeout = null;
                }, 10000); 
            }
        }


        // --- RETOUR AU MENU ---
        function backToMenu(force = false) {
            // Nettoyage complet
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
            }
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
            }
            if (onDisconnectRef) { // Annuler onDisconnect si défini
                onDisconnectRef.cancel().catch(err => console.error("Error canceling onDisconnect on backToMenu:", err));
                onDisconnectRef = null;
            }

            // Gérer le forfait si le joueur quitte un match en cours volontairement
            if (currentMatchId && currentUser && !force) {
                const matchRef = ref(db, `matches/${currentMatchId}`);
                get(matchRef).then(snapshot => {
                    const matchData = snapshot.val();
                    // Vérifier si le match est toujours "playing" et que le joueur y est
                    if (matchData && matchData.status === 'playing') {
                        let quitterKey = null;
                        let opponentKeyForForfeit = null;

                        if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                            quitterKey = "p1"; opponentKeyForForfeit = "p2";
                        } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                            quitterKey = "p2"; opponentKeyForForfeit = "p1";
                        }

                        // S'assurer que le joueur est bien dans le match et qu'il y a un adversaire actif
                        if (quitterKey && matchData.players[opponentKeyForForfeit] && matchData.players[opponentKeyForForfeit].status === 'connected') { 
                            const updates = {};
                            updates[`players/${quitterKey}/pv`] = 0; 
                            updates[`players/${quitterKey}/status`] = 'forfeited';
                            updates.status = 'forfeited';
                            updates.winner = opponentKeyForForfeit; 
                            updates.history = [...(matchData.history || []), `${currentUser.pseudo} a quitté le match. ${matchData.players[opponentKeyForForfeit].pseudo} gagne par forfait.`];
                            
                            update(matchRef, updates)
                                .then(() => console.log(`${currentUser.pseudo} left and forfeited match ${currentMatchId}`))
                                .catch(err => console.error("Error updating match on forfeit:", err));
                        }
                    }
                }).catch(err => console.error("Error getting match for backToMenu forfeit:", err));
            }

            currentMatchId = null;
            hasPlayedThisTurn = false;
            youKey = null; // Réinitialiser
            opponentKey = null; // Réinitialiser

            showMessage("action-msg", ""); 
            showMessage("match-msg", ""); 

            document.getElementById("game").style.display = "none";
            document.getElementById("match").style.display = "block";
            
            matchIdInput.value = "";
        }

        backToMenuBtn.onclick = () => backToMenu(); 
    </script>
</body>
</html>