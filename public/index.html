<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Duel 1v1 Multijoueur</title>
    <style>
        :root {
            --main-color: #00ffd5;
            --bg-color: #0e0e0e;
            --text-color: #e0e0e0;
            --input-bg: #1a1a1a;
            --button-bg: linear-gradient(135deg, #00ffd5, #00b3ff);
            --danger: #ff4d6d;
            --warning: #ff7700;
            --critical: #ff0000;
            --heal: #00ff88;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            text-align: center;
        }

        h1, h2, h3 {
            color: var(--main-color);
            margin-bottom: 15px;
        }

        input {
            padding: 12px;
            margin: 10px 5px;
            border-radius: 8px;
            border: 1px solid #222;
            background-color: var(--input-bg);
            color: #eee;
            font-size: 1rem;
            width: 200px;
            max-width: 80vw;
            outline: none;
            transition: 0.3s;
        }

        input:focus {
            box-shadow: 0 0 6px 2px var(--main-color);
            background-color: #222;
        }

        button {
            background: var(--button-bg);
            border: none;
            border-radius: 8px;
            color: #0e0e0e;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 10px 8px;
            padding: 12px 30px;
            transition: 0.3s ease;
            min-width: 150px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 213, 0.4);
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
            color: #aaa;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 15px;
        }

        #actions {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        #actions button {
            flex-grow: 1;
            min-width: 120px;
        }

        #history {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background: #222;
            color: #eee;
            text-align: left;
            border-radius: 8px;
            margin-top: 15px;
        }

        #history p {
            margin: 6px 0;
            font-size: 0.95rem;
            color: #a0a0a0;
        }

        #auth-msg,
        #match-msg,
        #action-msg {
            color: var(--danger);
            font-weight: bold;
            margin-top: 12px;
            min-height: 26px;
        }

        #game p {
            font-size: 1.1rem;
            margin: 8px 0;
        }

        #you-name, #opponent-name {
            font-weight: 700;
            color: var(--main-color);
        }

        .player-info {
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #1c1c1c;
        }

        .health-bar-container {
            width: 100%;
            background-color: #555;
            border-radius: 5px;
            height: 20px;
            margin-top: 5px;
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            width: 100%;
            background-color: var(--heal);
            border-radius: 5px;
            transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
            text-align: center;
            color: black;
            font-weight: bold;
            line-height: 20px;
        }

        #you-health-bar.low,
        #opponent-health-bar.low {
            background-color: var(--warning);
        }

        #you-health-bar.critical,
        #opponent-health-bar.critical {
            background-color: var(--critical);
        }

        #opponent-health-bar {
            background-color: var(--danger);
        }

        #timer-display {
            font-weight: 700;
            font-size: 1.2rem;
            margin-top: 12px;
            color: #ffdd00;
        }

        #timer-progress-bar-container {
            width: 90%;
            max-width: 400px;
            height: 10px;
            background: #333;
            margin: 10px auto;
            border-radius: 5px;
            overflow: hidden;
        }

        #timer-progress-bar {
            height: 100%;
            width: 100%;
            background-color: var(--main-color);
            transition: width 1s linear;
            border-radius: 5px;
        }

        .damage-effect {
            animation: damagePulse 0.5s ease-out;
        }

        @keyframes damagePulse {
            0% { transform: scale(1); color: var(--danger); }
            50% { transform: scale(1.1); color: var(--critical); }
            100% { transform: scale(1); color: var(--danger); }
        }

        .heal-effect {
            animation: healPulse 1s ease-out;
        }

        @keyframes healPulse {
            0% { transform: scale(1); color: var(--heal); }
            50% { transform: scale(1.1); color: #88ffcc; }
            100% { transform: scale(1); color: var(--heal); }
        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.8rem;
            }

            input,
            button {
                width: calc(100% - 20px);
                margin: 10px auto;
                display: block;
            }

            #actions {
                flex-direction: column;
            }

            #actions button {
                width: 100%;
            }

            .container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>Duel 1v1 Multijoueur</h1>

    <div id="auth" class="container">
        <h2>Authentification</h2>
        <input id="pseudo" placeholder="Pseudo (min 2 caractères)" />
        <input id="code" type="password" placeholder="Code (4 chiffres)" maxlength="4" />
        <button id="signup-btn">S'inscrire</button>
        <button id="login-btn">Connexion</button>
        <p id="auth-msg"></p>
    </div>

    <div id="match" style="display:none;" class="container">
        <h2>Matchmaking</h2>
        <p>Connecté en tant que <strong id="player-name"></strong></p>
        <input id="match-id" placeholder="Code du match (ex: duel123)" />
        <button id="create-match-btn">Créer un match</button>
        <button id="join-match-btn">Rejoindre un match</button>
        <p id="match-msg"></p>
    </div>

    <div id="game" style="display:none;" class="container">
        <h2>Match: <span id="current-match"></span></h2>
        
        <div class="player-info">
            <p><strong id="you-name"></strong> (PV: <span id="you-pv-display">100</span>)</p>
            <div class="health-bar-container">
                <div id="you-health-bar" class="health-bar">100%</div>
            </div>
        </div>

        <div class="player-info">
            <p><strong id="opponent-name">Adversaire</strong> (PV: <span id="opponent-pv-display">100</span>)</p>
            <div class="health-bar-container">
                <div id="opponent-health-bar" class="health-bar">100%</div>
            </div>
        </div>

        <p id="timer-display">Temps restant : <span id="timer-value">30</span>s</p> <div id="timer-progress-bar-container"> <div id="timer-progress-bar"></div> </div>
        
        <p id="action-msg"></p>

        <div id="actions">
            <button id="attack-btn">🗡️ Attaquer</button>
            <button id="defend-btn">🛡️ Défendre</button>
            <button id="heal-btn">🧪 Se soigner</button>
        </div>

        <h3>Historique</h3>
        <div id="history"></div>

        <button id="back-to-menu-btn" style="margin-top: 20px; background: #555;">Quitter le Match</button>
    </div>

    <script type="module">
        // Embedded JavaScript from user input
        // Import Firebase (corrected paths)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, update, push, child, remove, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";
        // Analytics can be optional if not used, but kept as per original code
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-analytics.js";

        // --- CONFIGURATION FIREBASE ---
        // IMPORTANT: This is the user-provided Firebase configuration.
        // For production, ensure this is secured and properly set up.
        const firebaseConfig = {
            apiKey: "AIzaSyA-e19z8T3c1K46YmJY8s9EAbO9BRes7fA", // Replace with your actual API key if this is a placeholder
            authDomain: "mini-duel-de-cartes.firebaseapp.com",
            databaseURL: "https://mini-duel-de-cartes-default-rtdb.firebaseio.com",
            projectId: "mini-duel-de-cartes",
            storageBucket: "mini-duel-de-cartes.appspot.com", // Corrected common typo: .firebasestorage.app or .appspot.com
            messagingSenderId: "1084207708579",
            appId: "1:1084207708579:web:f1312b68b7eb08f9d44216",
            measurementId: "G-7YW3J41XZF" // Optional, for Google Analytics
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        // const analytics = getAnalytics(app); // Uncomment if you use analytics
        const db = getDatabase(app);

        // --- VARIABLES GLOBALES ---
        let currentUser = null; // { pseudo, code }
        let currentMatchId = null; // Renamed for clarity
        let hasPlayedThisTurn = false;
        let timerInterval = null;
        const timerMax = 30; // secondes
        let timerCount = timerMax;

        // Variables pour gérer les timeouts/intervals de nettoyage des matchs
        let unsubscribeMatchCreationListener = null; 
        let matchDeletionTimeout = null; // Renamed for clarity (used for finished/forfeited matches)
        let currentMatchUnsubscribe = null; // To store the unsubscribe function for the main match listener

        // --- DOM Elements Cache ---
        const pseudoInput = document.getElementById("pseudo");
        const codeInput = document.getElementById("code");
        const authMsgEl = document.getElementById("auth-msg");
        const matchIdInput = document.getElementById("match-id");
        const matchMsgEl = document.getElementById("match-msg");
        const actionMsgEl = document.getElementById("action-msg");
        const youPvDisplayEl = document.getElementById("you-pv-display");
        const opponentPvDisplayEl = document.getElementById("opponent-pv-display");
        const youHealthBarEl = document.getElementById("you-health-bar");
        const opponentHealthBarEl = document.getElementById("opponent-health-bar");
        const timerValueEl = document.getElementById("timer-value");
        const timerProgressBarEl = document.getElementById("timer-progress-bar");
        const attackBtn = document.getElementById("attack-btn");
        const defendBtn = document.getElementById("defend-btn");
        const healBtn = document.getElementById("heal-btn");
        const backToMenuBtn = document.getElementById("back-to-menu-btn");


        // --- FONCTIONS UTILITAIRES ---

        function showMessage(elementId, message, isSuccess = false) {
            const el = document.getElementById(elementId);
            if (el) {
                el.style.color = isSuccess ? "#00ff88" : "#ff4d6d";
                el.textContent = message;
            }
        }

        function disableActionButtons(disabled) {
            attackBtn.disabled = disabled;
            defendBtn.disabled = disabled;
            healBtn.disabled = disabled;
        }
        
        function updateHealthBar(healthBarElement, pvDisplayElement, currentPV) {
            const percentage = Math.max(0, Math.min(100, currentPV));
            healthBarElement.style.width = `${percentage}%`;
            healthBarElement.textContent = `${percentage}%`; // Show percentage on bar
            pvDisplayElement.textContent = currentPV;

            healthBarElement.classList.remove('low', 'critical');
            if (currentPV < 10) {
                healthBarElement.classList.add('critical');
            } else if (currentPV < 30) {
                healthBarElement.classList.add('low');
            }
        }

        function updateTimerUI(value) {
            timerValueEl.textContent = value;
            const progress = (value / timerMax) * 100;
            timerProgressBarEl.style.width = `${progress}%`;
            timerProgressBarEl.style.backgroundColor = `hsl(${progress * 1.2}, 100%, 50%)`; // Green to Red
        }


        // --- AUTHENTIFICATION ---

        document.getElementById("signup-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (pseudo.length < 2) {
                showMessage("auth-msg", "Pseudo trop court (min 2 caractères).");
                return;
            }
            if (!/^\d{4}$/.test(code)) {
                showMessage("auth-msg", "Code doit être composé de 4 chiffres.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("auth-msg", "Ce pseudo est déjà pris.");
                } else {
                    set(userRef, { code, wins: 0, losses: 0, createdAt: serverTimestamp() })
                        .then(() => {
                            showMessage("auth-msg", "Inscription réussie !", true);
                            currentUser = { pseudo, code };
                            afterLogin();
                        })
                        .catch(error => {
                            console.error("Signup error:", error);
                            showMessage("auth-msg", "Erreur lors de l'inscription.");
                        });
                }
            }).catch(error => {
                console.error("Checking user for signup error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("login-btn").onclick = () => {
            const pseudo = pseudoInput.value.trim();
            const code = codeInput.value.trim();

            if (!pseudo || !code) {
                showMessage("auth-msg", "Pseudo et code requis.");
                return;
            }

            const userRef = ref(db, `users/${pseudo}`);
            get(userRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("auth-msg", "Pseudo inconnu.");
                } else {
                    const data = snapshot.val();
                    if (data.code === code) {
                        showMessage("auth-msg", "Connexion réussie !", true);
                        currentUser = { pseudo, code };
                        afterLogin();
                    } else {
                        showMessage("auth-msg", "Code incorrect.");
                    }
                }
            }).catch(error => {
                console.error("Login error:", error);
                showMessage("auth-msg", "Erreur de base de données.");
            });
        };

        function afterLogin() {
            document.getElementById("auth").style.display = "none";
            document.getElementById("match").style.display = "block";
            document.getElementById("player-name").textContent = currentUser.pseudo;
            showMessage("auth-msg", ""); // Clear auth message
            pseudoInput.value = ""; // Clear inputs
            codeInput.value = "";
        }

        // --- MATCH ---

        document.getElementById("create-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code pour le match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (snapshot.exists()) {
                    showMessage("match-msg", "Ce code de match est déjà utilisé.");
                } else {
                    const initialMatchData = {
                        players: {
                            p1: { pseudo: currentUser.pseudo, pv: 100, defending: false, status: 'connected', lastSeen: serverTimestamp() },
                            p2: null
                        },
                        turn: "p1",
                        actions: {}, // Consider if this is used or can be removed
                        history: [`Match ${matchId} créé par ${currentUser.pseudo}. En attente d'un adversaire...`],
                        status: "waiting", // waiting, playing, finished, forfeited
                        createdAt: serverTimestamp()
                    };
                    set(matchRef, initialMatchData).then(() => {
                        showMessage("match-msg", "Match créé. En attente de l'adversaire...", true);
                        startMatchMonitoring(matchId); // Changed function name

                        // Cleanup listener for unjoined match
                        if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); // Clear previous
                        unsubscribeMatchCreationListener = onValue(matchRef, (matchSnapshot) => {
                            const matchData = matchSnapshot.val();
                            if (matchData && matchData.status === 'waiting' && !matchData.players.p2 && typeof matchData.createdAt === 'number') {
                                const timeElapsed = Date.now() - matchData.createdAt;
                                if (timeElapsed > 60000) { // 1 minute
                                    console.log(`Match ${matchId} non rejoint après 1 minute, suppression.`);
                                    remove(matchRef)
                                        .then(() => {
                                            showMessage("match-msg", "Match expiré et supprimé (aucun adversaire).");
                                            if (currentMatchId === matchId) { // If this was the current match for the creator
                                                backToMenu(true); // true indicates an unexpected end
                                            }
                                        })
                                        .catch(err => console.error("Error removing expired match:", err));
                                    if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener(); // Self-unsubscribe
                                    unsubscribeMatchCreationListener = null;
                                }
                            } else if (matchData && matchData.players.p2) { // Opponent joined
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                            } else if (!matchData) { // Match was deleted elsewhere
                                if (unsubscribeMatchCreationListener) unsubscribeMatchCreationListener();
                                unsubscribeMatchCreationListener = null;
                            }
                        });

                    }).catch(error => {
                        console.error("Error creating match:", error);
                        showMessage("match-msg", "Erreur lors de la création du match.");
                    });
                }
            }).catch(error => {
                console.error("Error checking match existence:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };

        document.getElementById("join-match-btn").onclick = () => {
            const matchId = matchIdInput.value.trim();
            if (!matchId) {
                showMessage("match-msg", "Veuillez indiquer un code de match.");
                return;
            }
            if (!currentUser) {
                showMessage("match-msg", "Erreur : utilisateur non connecté.");
                return;
            }

            const matchRef = ref(db, `matches/${matchId}`);
            get(matchRef).then(snapshot => {
                if (!snapshot.exists()) {
                    showMessage("match-msg", "Ce match n'existe pas.");
                    return;
                }

                const matchData = snapshot.val();
                if (matchData.players.p1.pseudo === currentUser.pseudo) {
                    showMessage("match-msg", "Vous ne pouvez pas rejoindre votre propre match en tant qu'adversaire. Si vous l'avez créé, attendez un joueur.");
                    startMatchMonitoring(matchId); // Allow creator to re-enter monitoring if they left and came back
                    return;
                }
                if (matchData.players.p2) {
                    showMessage("match-msg", "Ce match est déjà complet.");
                    return;
                }
                if (matchData.status !== 'waiting') {
                    showMessage("match-msg", "Ce match n'est plus en attente de joueurs.");
                    return;
                }
                
                const updates = {};
                updates[`players/p2`] = { pseudo: currentUser.pseudo, pv: 100, defending: false, status: 'connected', lastSeen: serverTimestamp() };
                updates[`status`] = 'playing';
                updates[`history`] = [...(matchData.history || []), `${currentUser.pseudo} a rejoint le match ! Le duel commence.`];


                update(matchRef, updates).then(() => {
                    showMessage("match-msg", "Vous avez rejoint le match !", true);
                    startMatchMonitoring(matchId);
                }).catch(error => {
                    console.error("Error joining match:", error);
                    showMessage("match-msg", "Erreur pour rejoindre le match.");
                });
            }).catch(error => {
                console.error("Error getting match to join:", error);
                showMessage("match-msg", "Erreur de base de données.");
            });
        };
        
        // --- DÉBUT ET SUIVI DU MATCH ---
        function startMatchMonitoring(id) {
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe(); // Unsubscribe from any previous match listener
            }
            
            currentMatchId = id;
            const matchRef = ref(db, `matches/${id}`);

            document.getElementById("match").style.display = "none";
            document.getElementById("game").style.display = "block";
            document.getElementById("current-match").textContent = id;
            document.getElementById("you-name").textContent = currentUser.pseudo;
            document.getElementById("history").innerHTML = ""; // Clear history on new match start

            hasPlayedThisTurn = false;
            disableActionButtons(true); // Initially disable until turn is confirmed
            actionMsgEl.textContent = "Chargement du match...";

            currentMatchUnsubscribe = onValue(matchRef, async (snapshot) => { // Added async keyword
                const data = snapshot.val();
                if (!data) {
                    // Match deleted or non-existent
                    if (currentMatchId === id) { // Check if this is still the active match for the client
                        showMessage("action-msg", "Le match a été terminé ou supprimé.");
                        if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                        currentMatchUnsubscribe = null;
                        setTimeout(() => backToMenu(true), 3000);
                    }
                    return;
                }

                // Determine player roles
                let you, opponent, youKey, opponentKey;
                if (data.players.p1 && data.players.p1.pseudo === currentUser.pseudo) {
                    you = data.players.p1; youKey = "p1";
                    opponent = data.players.p2; opponentKey = "p2";
                } else if (data.players.p2 && data.players.p2.pseudo === currentUser.pseudo) {
                    you = data.players.p2; youKey = "p2";
                    opponent = data.players.p1; opponentKey = "p1";
                } else {
                    // Not a player in this match (e.g., if kicked or error)
                    actionMsgEl.textContent = "Vous n'êtes pas un joueur dans ce match.";
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    return;
                }
                
                // Handle onDisconnect for the current player
                // This should ideally be set once when the player is confirmed in the match.
                // Be careful about re-setting it on every onValue update.
                // A simple approach: set it if 'you' is defined and status is 'connected'.
                if (you && you.status === 'connected') {
                    const yourPlayerRef = ref(db, `matches/${id}/players/${youKey}`);
                    // Only set onDisconnect once when the player connects to the match
                    if (!you._onDisconnectSet) { // Use a flag to avoid re-setting
                        onDisconnect(yourPlayerRef).update({
                            pv: 0, // Or some indicator of forfeit
                            status: 'disconnected',
                            lastSeen: serverTimestamp() 
                        }).catch(error => console.error("Error setting onDisconnect:", error));
                        // Mark the flag as set
                        if (you) you._onDisconnectSet = true;
                    }
                    // Also update 'lastSeen' periodically while connected (not implemented here for brevity)
                    update(yourPlayerRef, { lastSeen: serverTimestamp(), status: 'connected' }); // Mark as seen now
                }


                // Update UI with player data
                updateHealthBar(youHealthBarEl, youPvDisplayEl, you.pv);
                document.getElementById("you-name").textContent = `${you.pseudo} (Vous)`;

                if (opponent) {
                    updateHealthBar(opponentHealthBarEl, opponentPvDisplayEl, opponent.pv);
                    document.getElementById("opponent-name").textContent = opponent.pseudo;
                } else {
                    opponentPvDisplayEl.textContent = "N/A";
                    opponentHealthBarEl.style.width = "0%";
                    opponentHealthBarEl.textContent = "0%";
                    document.getElementById("opponent-name").textContent = "En attente...";
                }
                
                // If waiting for P2
                if (data.status === "waiting" || !opponent) {
                    actionMsgEl.textContent = "En attente de l'adversaire...";
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;
                    updateTimerUI(timerMax); // Reset timer display
                    return;
                }
                
                // Check for opponent disconnect/forfeit explicitly
                let opponentDisconnected = opponent.status === 'disconnected' || opponent.status === 'forfeited';


                // Game End Conditions
                if (you.pv <= 0 || opponent.pv <= 0 || data.status === 'finished' || data.status === 'forfeited' || opponentDisconnected) {
                    disableActionButtons(true);
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = null;

                    // Cancel onDisconnect for this player since match is ending
                    const playerRefToCancel = ref(db, `matches/${id}/players/${youKey}`);
                    onDisconnect(playerRefToCancel).cancel().catch(error => console.error("Error cancelling onDisconnect:", error));
                    
                    let finalMessage = "";
                    let yourResult = "draw"; // draw, win, loss

                    if (opponentDisconnected && you.pv > 0) {
                        finalMessage = `L'adversaire (${opponent.pseudo}) a quitté. Vous avez gagné par forfait !`;
                        yourResult = "win";
                    } else if (you.pv <= 0 && opponent.pv <= 0) {
                        finalMessage = "Match Nul !";
                    } else if (you.pv <= 0) {
                        finalMessage = `Vous avez perdu contre ${opponent.pseudo}...`;
                        yourResult = "loss";
                    } else if (opponent.pv <= 0) {
                        finalMessage = `Vous avez gagné contre ${opponent.pseudo} !`;
                        yourResult = "win";
                    } else if (data.status === 'forfeited') { // General forfeit status
                        if (data.winner === youKey) {
                            finalMessage = `Victoire par forfait !`;
                            yourResult = "win";
                        } else {
                            finalMessage = `Défaite par forfait.`;
                            yourResult = "loss";
                        }
                    }
                    
                    actionMsgEl.textContent = finalMessage;
                    updateUserStats(yourResult);

                    // Schedule match deletion
                    if (!matchDeletionTimeout) { // Prevent multiple timeouts
                        actionMsgEl.textContent += " Retour au menu dans 10 secondes...";
                        matchDeletionTimeout = setTimeout(() => {
                            console.log(`Match ${id} terminé/forfait, tentative de suppression.`);
                            // Only p1 (creator) should ideally delete the match to avoid race conditions
                            // Or, implement a cloud function for cleanup.
                            // For simplicity here, any player can trigger if they are the last one.
                            // A better check would be if (youKey === 'p1' || opponent.status !== 'connected')
                            remove(matchRef)
                                .then(() => console.log(`Match ${id} supprimé.`))
                                .catch(err => console.error("Error removing finished match:", err));
                            backToMenu(true); // true indicates an unexpected end or forced return
                            matchDeletionTimeout = null;
                        }, 10000); // 10 seconds
                    }
                    return; // End processing for this update
                }

                // Process actions if available and it's the current turn
                // This section assumes actions are processed at the start of a turn by the current player
                if (data.turn === youKey && data.actions && Object.keys(data.actions).length === 2) {
                    // Both players have submitted actions
                    const player1Action = data.actions.p1;
                    const player2Action = data.actions.p2;

                    let p1PV = data.players.p1.pv;
                    let p2PV = data.players.p2.pv;
                    let historyUpdates = [...(data.history || [])];

                    // Reset defending status for both players
                    let p1Defending = false;
                    let p2Defending = false;

                    // Apply actions
                    historyUpdates.push(`--- Début du tour ---`);
                    
                    // Player 1's action
                    if (player1Action === 'attack') {
                        historyUpdates.push(`${data.players.p1.pseudo} attaque !`);
                        if (player2Action === 'defend') {
                            p2PV -= 5; // Reduced damage if defending
                            historyUpdates.push(`${data.players.p2.pseudo} se défend, subit 5 PV de dégâts.`);
                        } else {
                            p2PV -= 10; // Full damage
                            historyUpdates.push(`${data.players.p2.pseudo} subit 10 PV de dégâts.`);
                        }
                    } else if (player1Action === 'defend') {
                        p1Defending = true;
                        historyUpdates.push(`${data.players.p1.pseudo} se prépare à défendre.`);
                    } else if (player1Action === 'heal') {
                        p1PV = Math.min(100, p1PV + 15);
                        historyUpdates.push(`${data.players.p1.pseudo} se soigne et récupère 15 PV.`);
                    }

                    // Player 2's action (only if not defending or attacking)
                    if (player2Action === 'attack') {
                        historyUpdates.push(`${data.players.p2.pseudo} attaque !`);
                        if (player1Action === 'defend') {
                            p1PV -= 5; // Reduced damage if defending
                            historyUpdates.push(`${data.players.p1.pseudo} se défend, subit 5 PV de dégâts.`);
                        } else {
                            p1PV -= 10; // Full damage
                            historyUpdates.push(`${data.players.p1.pseudo} subit 10 PV de dégâts.`);
                        }
                    } else if (player2Action === 'defend') {
                        p2Defending = true;
                        historyUpdates.push(`${data.players.p2.pseudo} se prépare à défendre.`);
                    } else if (player2Action === 'heal') {
                        p2PV = Math.min(100, p2PV + 15);
                        historyUpdates.push(`${data.players.p2.pseudo} se soigne et récupère 15 PV.`);
                    }
                    historyUpdates.push(`--- Fin du tour ---`);

                    // Ensure PV don't go below 0
                    p1PV = Math.max(0, p1PV);
                    p2PV = Math.max(0, p2PV);

                    // Determine next turn
                    let nextTurn = (data.turn === 'p1') ? 'p2' : 'p1';
                    if (p1PV <= 0 || p2PV <= 0) {
                        nextTurn = "finished"; // Mark as finished if game over
                    }

                    const updates = {
                        [`players/p1/pv`]: p1PV,
                        [`players/p2/pv`]: p2PV,
                        [`players/p1/defending`]: p1Defending, // Reset defending status for next turn
                        [`players/p2/defending`]: p2Defending, // Reset defending status for next turn
                        history: historyUpdates,
                        actions: {}, // Clear actions for next turn
                        turn: nextTurn,
                        lastTurnProcessedAt: serverTimestamp() // To help with timer synchronization
                    };

                    // Set game status if finished
                    if (nextTurn === "finished") {
                        updates.status = "finished";
                        if (p1PV > 0 && p2PV <= 0) { updates.winner = "p1"; updates.loser = "p2"; }
                        else if (p2PV > 0 && p1PV <= 0) { updates.winner = "p2"; updates.loser = "p1"; }
                        else { updates.winner = "draw"; } // Both 0 or equal and game ended
                    }

                    await update(matchRef, updates).catch(error => console.error("Error updating match after actions:", error));
                    hasPlayedThisTurn = false; // Reset for the next turn
                }


                // Turn Management
                if (data.turn === youKey) {
                    if (hasPlayedThisTurn) {
                        disableActionButtons(true);
                        actionMsgEl.textContent = "Action jouée. En attente de l'adversaire...";
                        if (timerInterval) clearInterval(timerInterval); // Stop timer if already played
                        timerInterval = null;
                    } else {
                        disableActionButtons(false);
                        actionMsgEl.textContent = "C'est votre tour ! Choisissez une action.";
                        if (!timerInterval) { // Start timer only if not already running for this turn
                            resetTimerAndStart(youKey, opponentKey);
                        }
                    }
                } else { // Opponent's turn
                    disableActionButtons(true);
                    actionMsgEl.textContent = `Tour de ${opponent ? opponent.pseudo : 'l\'adversaire'}. Veuillez patienter...`;
                    if (timerInterval) clearInterval(timerInterval); // Stop your timer
                    timerInterval = null;
                    hasPlayedThisTurn = false; // Reset for your next turn
                    updateTimerUI(timerMax); // Show full timer for opponent visually
                }

                // Update History
                const histEl = document.getElementById("history");
                histEl.innerHTML = ""; // Clear and redraw
                (data.history || []).forEach(entry => {
                    const p = document.createElement("p");
                    p.textContent = entry;
                    histEl.appendChild(p);
                });
                histEl.scrollTop = histEl.scrollHeight; // Auto-scroll

            }, (error) => {
                console.error("Error listening to match data:", error);
                showMessage("action-msg", "Erreur de connexion au match. Retour au menu.");
                if (currentMatchUnsubscribe) currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
                setTimeout(() => backToMenu(true), 3000);
            });
        }

        // --- GESTION DU TIMER ---
        function resetTimerAndStart(currentPlayerKey, opponentPlayerKey) {
            if (timerInterval) clearInterval(timerInterval);
            timerCount = timerMax;
            updateTimerUI(timerCount);

            timerInterval = setInterval(async () => {
                timerCount--;
                updateTimerUI(timerCount);

                if (timerCount <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    disableActionButtons(true); // Disable actions if time runs out

                    // Record an automatic action (e.g., defend) if no action was chosen
                    if (!hasPlayedThisTurn) {
                        const matchRef = ref(db, `matches/${currentMatchId}`);
                        const matchSnapshot = await get(matchRef);
                        const matchData = matchSnapshot.val();

                        if (matchData && matchData.turn === currentPlayerKey) {
                            // If player hasn't played and it's their turn (and still their turn according to data)
                            const playerAction = 'defend'; // Default action on timeout
                            const updates = {};
                            updates[`actions/${currentPlayerKey}`] = playerAction;
                            
                            // Log the auto-action in history
                            const newHistory = [...(matchData.history || []), 
                                `${currentUser.pseudo} n'a pas agi à temps et s'est automatiquement défendu.`
                            ];
                            updates.history = newHistory;

                            await update(matchRef, updates).catch(error => console.error("Error updating match with timeout action:", error));
                            hasPlayedThisTurn = true; // Mark as played
                            actionMsgEl.textContent = "Temps écoulé ! Votre action a été automatiquement choisie (Défense).";
                        }
                    }
                    // The main onValue listener will handle processing actions and switching turns once both actions are recorded.
                }
            }, 1000); // Update every second
        }

        // --- ACTIONS DU JOUEUR ---
        async function performAction(actionType) {
            if (!currentMatchId || !currentUser || hasPlayedThisTurn) {
                showMessage("action-msg", "Action impossible pour le moment.");
                return;
            }

            const matchRef = ref(db, `matches/${currentMatchId}`);
            const matchSnapshot = await get(matchRef);
            const matchData = matchSnapshot.val();

            if (!matchData) {
                showMessage("action-msg", "Match introuvable ou terminé.");
                backToMenu(true);
                return;
            }

            let youKey;
            if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                youKey = "p1";
            } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                youKey = "p2";
            } else {
                showMessage("action-msg", "Vous n'êtes pas un joueur dans ce match.");
                return;
            }

            if (matchData.turn !== youKey) {
                showMessage("action-msg", "Ce n'est pas votre tour !");
                return;
            }

            // Record action in Firebase
            const updates = {};
            updates[`actions/${youKey}`] = actionType;
            
            // Add a temporary message to history (actual turn resolution will add detailed messages)
            const actionDisplayName = {
                'attack': 'Attaque',
                'defend': 'Défense',
                'heal': 'Soin'
            }[actionType];
            const newHistory = [...(matchData.history || [])];
            newHistory.push(`${currentUser.pseudo} a choisi : ${actionDisplayName}.`);
            updates.history = newHistory;

            try {
                await update(matchRef, updates);
                hasPlayedThisTurn = true;
                disableActionButtons(true);
                actionMsgEl.textContent = `Vous avez choisi : ${actionDisplayName}. En attente de l'adversaire...`;
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = null; // Stop timer once action is made
            } catch (error) {
                console.error("Error performing action:", error);
                showMessage("action-msg", "Erreur lors de l'envoi de votre action.");
            }
        }

        attackBtn.onclick = () => performAction('attack');
        defendBtn.onclick = () => performAction('defend');
        healBtn.onclick = () => performAction('heal');


        // --- MISE À JOUR DES STATISTIQUES UTILISATEUR ---
        async function updateUserStats(result) {
            if (!currentUser || !currentUser.pseudo) return;

            const userStatsRef = ref(db, `users/${currentUser.pseudo}`);
            try {
                const snapshot = await get(userStatsRef);
                if (snapshot.exists()) {
                    let { wins, losses } = snapshot.val();
                    wins = wins || 0;
                    losses = losses || 0;

                    if (result === 'win') {
                        wins++;
                    } else if (result === 'loss') {
                        losses++;
                    }
                    // No change for 'draw' or 'disconnected' (handled by forfeit win)

                    await update(userStatsRef, { wins, losses });
                    console.log(`Stats for ${currentUser.pseudo} updated: Wins=${wins}, Losses=${losses}`);
                }
            } catch (error) {
                console.error("Error updating user stats:", error);
            }
        }


        // --- RETOUR AU MENU ---
        function backToMenu(force = false) {
            // Unsubscribe from current match listener if it exists
            if (currentMatchUnsubscribe) {
                currentMatchUnsubscribe();
                currentMatchUnsubscribe = null;
            }
            // Clear any active timers
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            // Clear any match deletion timeouts
            if (matchDeletionTimeout) {
                clearTimeout(matchDeletionTimeout);
                matchDeletionTimeout = null;
            }
            // Clear match creation listener if pending
            if (unsubscribeMatchCreationListener) {
                unsubscribeMatchCreationListener();
                unsubscribeMatchCreationListener = null;
            }

            // Remove player from the match if they are leaving voluntarily and match is not ended
            if (currentMatchId && currentUser && !force) {
                const matchRef = ref(db, `matches/${currentMatchId}`);
                get(matchRef).then(snapshot => {
                    const matchData = snapshot.val();
                    if (matchData && matchData.status === 'playing') {
                        let youKey = null;
                        if (matchData.players.p1 && matchData.players.p1.pseudo === currentUser.pseudo) {
                            youKey = "p1";
                        } else if (matchData.players.p2 && matchData.players.p2.pseudo === currentUser.pseudo) {
                            youKey = "p2";
                        }

                        if (youKey) {
                            const opponentKey = youKey === 'p1' ? 'p2' : 'p1';
                            const updates = {};
                            updates[`players/${youKey}/pv`] = 0; // Set PV to 0 for forfeit
                            updates[`players/${youKey}/status`] = 'forfeited';
                            updates.status = 'forfeited';
                            updates.winner = opponentKey; // Opponent wins by forfeit
                            updates.history = [...(matchData.history || []), `${currentUser.pseudo} a quitté le match et a perdu par forfait. ${matchData.players[opponentKey].pseudo} gagne.`];
                            
                            update(matchRef, updates)
                                .then(() => console.log(`${currentUser.pseudo} left and forfeited match ${currentMatchId}`))
                                .catch(err => console.error("Error updating match on forfeit:", err));
                        }
                    }
                }).catch(err => console.error("Error getting match for backToMenu forfeit:", err));
            }

            currentMatchId = null;
            hasPlayedThisTurn = false;
            showMessage("action-msg", ""); // Clear game messages
            showMessage("match-msg", ""); // Clear matchmaking messages

            // Hide game and show matchmaking
            document.getElementById("game").style.display = "none";
            document.getElementById("match").style.display = "block";
            
            // Re-enable matchmaking buttons and clear match ID input
            matchIdInput.value = "";
        }

        backToMenuBtn.onclick = () => backToMenu(); // Attach event listener

        // Initial setup on page load (if user was previously logged in, maybe local storage?)
        // For this example, we assume fresh start, so nothing specific on load.
        // You might want to implement a check for currentUser in localStorage here.
    </script>
</body>
</html>